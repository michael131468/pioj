<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pioj</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        :root {
            --bg-primary: #f4f5f7;
            --bg-secondary: white;
            --bg-tertiary: #f4f5f7;
            --text-primary: #172b4d;
            --text-secondary: #5e6c84;
            --border-color: #dfe1e6;
            --shadow: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-hover: 0 4px 8px rgba(0,0,0,0.1);
            --color-primary: #0052cc;
            --color-primary-hover: #0747a6;
            --color-secondary: #8b7dd8;
            --color-secondary-hover: #6554c0;
            --swimlane-header-start: #0052cc;
            --swimlane-header-end: #0747a6;
        }

        body.dark-mode {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3a3a3a;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --border-color: #404040;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-hover: 0 4px 8px rgba(0,0,0,0.4);
            --color-primary: #4c9aff;
            --color-primary-hover: #6bb3ff;
            --color-secondary: #9d8ee0;
            --color-secondary-hover: #8b7dd8;
            --swimlane-header-start: #4a4a4a;
            --swimlane-header-end: #5a5a5a;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: var(--bg-primary);
            margin: 0;
            padding: 0;
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
        }

        .header {
            background: var(--bg-secondary);
            padding: 15px 20px 10px 20px;
            border-radius: 0;
            margin: 0;
            margin-bottom: 15px;
            box-shadow: var(--shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .content-wrapper {
            padding: 0 20px 20px 20px;
        }

        .header h1 {
            color: var(--text-primary);
            margin-bottom: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .connection-info {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: normal;
        }

        .jira-host {
            color: #00875a;
        }

        .jira-error {
            color: #de350b;
        }

        .theme-toggle {
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            transition: all 0.3s;
        }

        .theme-toggle:hover {
            background: var(--bg-tertiary);
        }

        .config-section {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: flex-end;
        }

        .form-group {
            flex: 1;
            min-width: 200px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text-primary);
            font-size: 14px;
        }

        input, textarea {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            font-family: inherit;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        textarea {
            resize: vertical;
            min-height: 60px;
        }

        input:focus, textarea:focus {
            outline: none;
            border-color: var(--color-primary);
        }

        button {
            padding: 8px 16px;
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
        }

        button:hover {
            background: var(--color-primary-hover);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        button.secondary {
            background: var(--color-secondary);
        }

        button.secondary:hover {
            background: var(--color-secondary-hover);
        }

        button.danger {
            background: #de350b;
        }

        button.danger:hover {
            background: #bf2600;
        }

        .controls {
            background: var(--bg-secondary);
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .workstreams-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .swimlane {
            background: var(--bg-secondary);
            border-radius: 8px;
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .swimlane-header {
            background: linear-gradient(135deg, var(--swimlane-header-start) 0%, var(--swimlane-header-end) 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .swimlane-header h3 {
            font-size: 16px;
            font-weight: 600;
        }

        .swimlane-controls {
            display: flex;
            gap: 8px;
        }

        .swimlane-controls button {
            padding: 4px 12px;
            font-size: 12px;
            background: rgba(255, 255, 255, 0.2);
        }

        .swimlane-controls button:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .swimlane-body {
            padding: 15px;
        }

        .swimlane-config {
            margin-bottom: 15px;
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        .swimlane-config textarea {
            margin-top: 5px;
            font-size: 12px;
        }

        .workstream-summary {
            margin-bottom: 20px;
            padding: 15px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border-left: 4px solid var(--color-secondary);
        }

        .summary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .summary-header h4 {
            margin: 0;
            color: var(--text-primary);
            font-size: 15px;
        }

        .summary-meta {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .summary-regenerate {
            padding: 4px 10px;
            font-size: 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .summary-regenerate:hover {
            background: var(--color-secondary);
            color: white;
            border-color: var(--color-secondary);
        }

        .summary-content {
            line-height: 1.6;
            color: var(--text-primary);
            white-space: pre-wrap;
        }

        .workstream-analysis-box {
            margin-top: 20px;
            padding: 15px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border-left: 4px solid var(--color-primary);
        }

        .analysis-box-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .analysis-box-controls h4 {
            margin: 0;
            color: var(--text-primary);
            font-size: 15px;
        }

        .analysis-box-controls label {
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .analysis-box-controls select {
            padding: 6px 10px;
            font-size: 13px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
        }

        .analysis-box-controls button {
            padding: 6px 12px;
            font-size: 13px;
        }

        .custom-days-input {
            width: 80px;
            padding: 6px 10px;
            font-size: 13px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
        }

        .analysis-box-controls .checkbox-label {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: var(--text-secondary);
            cursor: pointer;
            white-space: nowrap;
            margin: 0;
            font-weight: normal;
        }

        .analysis-box-controls .checkbox-label input[type="checkbox"] {
            cursor: pointer;
            margin: 0;
        }

        .context-input {
            margin-top: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .context-input label {
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .context-input textarea {
            width: 100%;
            padding: 8px;
            font-size: 13px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-family: inherit;
            resize: vertical;
        }

        .export-progress {
            margin-top: 15px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
            color: var(--text-primary);
        }

        .progress-bar-container {
            width: 100%;
            height: 20px;
            background: var(--bg-primary);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--color-primary), var(--color-secondary));
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 11px;
            font-weight: bold;
        }

        .queries-display {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .query-display-item {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .query-display-header {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex-shrink: 0;
            min-width: 110px;
            padding-top: 8px;
            align-items: flex-end;
        }

        .query-display-header strong {
            font-size: 13px;
            line-height: 1.2;
        }

        .query-equals {
            color: var(--text-secondary);
            font-size: 16px;
            font-weight: bold;
            padding: 0 8px;
            align-self: flex-start;
            margin-top: 10px;
        }

        .query-type-badge {
            background: var(--color-primary);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            text-align: center;
            display: inline-block;
            line-height: 1;
            white-space: nowrap;
        }

        .query-display-item textarea {
            flex: 1;
            min-height: 50px;
            resize: vertical;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 11px;
            line-height: 1.5;
            padding: 8px;
        }

        .tickets-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
        }

        .kanban-board {
            display: flex;
            gap: 15px;
            overflow-x: auto;
            padding-bottom: 10px;
        }

        .kanban-column {
            flex: 1;
            min-width: 280px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            padding: 10px;
        }

        .kanban-column-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border-radius: 4px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .kanban-column-title {
            font-size: 14px;
        }

        .kanban-column-count {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .kanban-tickets {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .sub-swimlane {
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }

        .sub-swimlane-header {
            background: var(--bg-tertiary);
            padding: 8px 12px;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 13px;
            border-bottom: 1px solid var(--border-color);
        }

        .sub-swimlane-body {
            background: var(--bg-secondary);
            padding: 10px;
        }

        .group-by-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .group-by-toggle input[type="checkbox"] {
            width: auto;
            cursor: pointer;
        }

        .group-by-toggle label {
            margin: 0;
            cursor: pointer;
            font-weight: normal;
        }

        .group-by-options {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .group-by-options.hidden {
            display: none;
        }

        .grouping-options {
            display: flex;
            gap: 16px;
            margin-top: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .view-toggle {
            display: flex;
            gap: 4px;
            background: var(--bg-secondary);
            border-radius: 4px;
            padding: 2px;
            border: 1px solid var(--border-color);
        }

        .view-toggle button {
            padding: 4px 12px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            border-radius: 3px;
            font-weight: 500;
        }

        .view-toggle button:hover {
            background: var(--bg-tertiary);
        }

        .view-toggle button.active {
            background: var(--color-primary);
            color: white;
        }

        .table-view {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            background: var(--bg-secondary);
        }

        .table-view thead {
            background: var(--bg-tertiary);
            border-bottom: 2px solid var(--border-color);
        }

        .table-view th {
            padding: 10px 12px;
            text-align: left;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .table-view th.status-column {
            width: 120px;
        }

        .table-view th.key-column {
            width: 120px;
        }

        .table-view th.assignee-column {
            width: 150px;
        }

        .table-view th.points-column {
            width: 60px;
            text-align: center;
        }

        .table-view th.duration-column {
            width: 80px;
            text-align: center;
        }

        .table-view th.resolution-column {
            width: 120px;
        }

        .table-duration,
        .table-since {
            font-size: 12px;
            color: var(--text-secondary);
            text-align: center;
        }

        .table-resolution {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .ticket-duration,
        .ticket-since {
            font-size: 11px;
            color: var(--text-secondary);
            font-style: italic;
        }

        .ticket-resolution {
            font-size: 11px;
            color: var(--text-secondary);
            font-style: italic;
        }

        .table-view tbody tr {
            border-bottom: 1px solid #f4f5f7;
            transition: background 0.2s;
        }

        .table-view tbody tr:hover {
            background: var(--bg-tertiary);
        }

        .table-view td {
            padding: 8px 12px;
            color: var(--text-primary);
        }

        .table-key {
            color: var(--color-primary);
            font-weight: 600;
            text-decoration: none;
            white-space: nowrap;
        }

        .table-key:hover {
            text-decoration: underline;
        }

        .table-summary {
            color: var(--text-primary);
        }

        .table-status {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            color: white;
            white-space: nowrap;
        }

        .table-assignee {
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .table-points {
            text-align: center;
            font-weight: 600;
            color: #ff991f;
        }

        .table-view-container {
            overflow-x: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .table-empty {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
            font-style: italic;
        }

        .last-updated {
            font-size: 10px;
            color: #6b778c;
            text-align: right;
            padding: 8px 12px;
            margin-top: 10px;
            font-style: italic;
        }

        .tree-view {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 10px;
        }

        .tree-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .tree-controls.hidden {
            display: none;
        }

        .tree-control-button {
            padding: 4px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            border-radius: 3px;
            font-weight: 500;
        }

        .tree-control-button:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-color);
        }

        .tree-node {
            margin: 4px 0;
        }

        .tree-node-content {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            border-radius: 3px;
            transition: background 0.2s;
            cursor: pointer;
        }

        .tree-node-content:hover {
            background: var(--bg-tertiary);
        }

        .tree-indent {
            display: inline-block;
            width: 20px;
        }

        .tree-toggle {
            width: 16px;
            height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-right: 4px;
            cursor: pointer;
            user-select: none;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .tree-icon {
            margin-right: 6px;
            font-size: 14px;
        }

        .tree-key {
            color: var(--color-primary);
            font-weight: 600;
            margin-right: 8px;
            text-decoration: none;
            font-size: 13px;
        }

        .tree-key:hover {
            text-decoration: underline;
        }

        .tree-summary {
            color: var(--text-primary);
            flex: 1;
            font-size: 13px;
        }

        .tree-status {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            color: white;
            margin-left: 8px;
        }

        .tree-meta {
            font-size: 11px;
            color: var(--text-secondary);
            margin-left: 8px;
        }

        .tree-children {
            margin-left: 20px;
            border-left: 1px solid var(--border-color);
            padding-left: 10px;
        }

        .tree-link-label {
            font-size: 11px;
            color: #6b778c;
            font-style: italic;
            margin-left: 20px;
            padding: 4px 0;
        }

        .tree-empty {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
            font-style: italic;
        }

        .tree-node-not-in-query {
            opacity: 0.7;
        }

        .tree-node-not-in-query .tree-key,
        .tree-node-not-in-query .tree-summary,
        .tree-node-not-in-query .tree-meta {
            color: #6b778c;
            font-style: italic;
        }

        .tree-node-not-in-query .tree-status {
            opacity: 0.75;
        }

        .ticket-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 12px;
            transition: all 0.2s;
        }

        .ticket-card:hover {
            box-shadow: var(--shadow-hover);
            transform: translateY(-2px);
        }

        .ticket-key {
            color: var(--color-primary);
            font-weight: 600;
            margin-bottom: 8px;
            cursor: pointer;
            text-decoration: none;
            display: block;
        }

        .ticket-key:hover {
            text-decoration: underline;
        }

        .ticket-summary {
            color: var(--text-primary);
            margin-bottom: 8px;
            font-size: 14px;
            line-height: 1.4;
        }

        .ticket-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 12px;
        }

        .ticket-status {
            padding: 2px 8px;
            border-radius: 3px;
            font-weight: 500;
            color: white;
        }

        .status-new {
            background: #6554c0;
        }

        .status-indeterminate {
            background: var(--color-primary);
        }

        .status-review {
            background: #ff991f;
        }

        .status-done {
            background: #00875a;
        }

        .status-other {
            background: #5e6c84;
        }

        .ticket-assignee {
            color: var(--text-secondary);
        }

        .ticket-story-points {
            background: #ff991f;
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            font-weight: 600;
            font-size: 11px;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
        }

        .loading-with-spinner {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            vertical-align: middle;
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-top-color: var(--color-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            flex-shrink: 0;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .error {
            background: #ffebe6;
            color: #bf2600;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .success {
            background: #e3fcef;
            color: #006644;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-content h2 {
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        .modal-content .form-group {
            margin-bottom: 15px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .help-text {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .status-indicator.connected {
            background: #00875a;
        }

        .status-indicator.disconnected {
            background: #de350b;
        }

        .ticket-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 8px;
        }

        .jql-examples {
            background: var(--bg-tertiary);
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 12px;
        }

        .jql-examples strong {
            display: block;
            margin-bottom: 5px;
            color: var(--text-primary);
        }

        .jql-examples code {
            display: block;
            background: var(--bg-secondary);
            padding: 4px 8px;
            border-radius: 3px;
            margin: 4px 0;
            font-family: 'Monaco', 'Courier New', monospace;
        }

        .query-stack {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .query-item {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .query-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .query-number {
            font-weight: 600;
            color: var(--color-primary);
            font-size: 14px;
        }

        .query-actions {
            display: flex;
            gap: 6px;
        }

        .query-actions button {
            padding: 4px 8px;
            font-size: 14px;
            line-height: 1;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-primary);
        }

        .query-actions button:hover:not(:disabled) {
            background: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
        }

        .query-actions button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .query-name-input {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 13px;
            margin-bottom: 8px;
        }

        .query-type-select {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 13px;
            margin-bottom: 8px;
            font-weight: 600;
            cursor: pointer;
        }

        .query-ref-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 8px;
        }

        .query-ref-btn {
            padding: 4px 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--color-primary);
            border-radius: 4px;
            color: var(--color-primary);
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .query-ref-btn:hover {
            background: var(--color-primary);
            color: white;
        }

        .query-placeholder-btn {
            padding: 4px 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--color-secondary);
            border-radius: 4px;
            color: var(--color-secondary);
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .query-placeholder-btn:hover {
            background: var(--color-secondary);
            color: white;
        }

        .query-jql-textarea {
            width: 100%;
            min-height: 60px;
            padding: 8px 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            resize: vertical;
        }

        .query-help-text {
            margin-top: 6px;
            font-size: 11px;
            color: var(--text-secondary);
            font-style: italic;
        }

        .add-query-btn {
            align-self: flex-start;
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border: 1px dashed var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 14px;
        }

        .add-query-btn:hover {
            background: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
            border-style: solid;
        }

        .query-flow-indicator {
            background: var(--bg-tertiary);
            padding: 10px 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 13px;
            color: var(--text-secondary);
            border-left: 3px solid var(--color-primary);
        }

        .query-flow-indicator strong {
            color: var(--text-primary);
        }

        .query-result-item {
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }

        .query-result-header-simple {
            background: var(--bg-tertiary);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 42px;
        }

        .query-result-content-simple {
            padding: 10px 15px;
            background: var(--bg-secondary);
        }

        .ticket-keys-list {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.8;
            color: var(--text-secondary);
        }

        .ticket-key-link {
            color: var(--color-primary);
            text-decoration: none;
            font-weight: 500;
        }

        .ticket-key-link:hover {
            text-decoration: underline;
        }

        .query-result-title {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 14px;
        }

        .query-result-count {
            color: var(--color-primary);
            font-weight: 600;
            vertical-align: middle;
        }

        .query-result-content {
            max-height: 300px;
            overflow-y: auto;
        }

        .query-result-content.collapsed {
            display: none;
        }

        .query-result-item.has-error {
            border-color: #de350b;
        }

        .query-type-badge {
            display: inline-block;
            padding: 2px 8px;
            background: var(--color-secondary);
            color: white;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 6px;
        }

        .query-status-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            vertical-align: middle;
            line-height: 1.4;
        }

        .query-pending {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .query-loading {
            background: var(--color-primary);
            color: white;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .query-skipped-badge {
            display: inline-block;
            padding: 2px 8px;
            background: var(--text-secondary);
            color: white;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 6px;
        }

        .query-error-badge {
            display: inline-block;
            padding: 2px 8px;
            background: #de350b;
            color: white;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 6px;
        }

        .query-result-item.loading {
            border-left: 3px solid var(--color-primary);
        }

        .final-results {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid var(--border-color);
        }

        .final-results h3 {
            color: var(--text-primary);
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .quick-nav {
            background: var(--bg-secondary);
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
        }

        .quick-nav h3 {
            color: var(--text-primary);
            font-size: 14px;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .quick-nav-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .quick-nav-item {
            background: var(--bg-tertiary);
            padding: 6px 12px;
            border-radius: 4px;
            color: var(--text-primary);
            text-decoration: none;
            font-size: 14px;
            transition: background 0.2s;
        }

        .quick-nav-item:hover {
            background: var(--bg-tertiary);
        }

        .quick-nav-item .count {
            color: var(--text-secondary);
            font-size: 12px;
            margin-left: 4px;
        }

        .reorder-buttons {
            display: flex;
            gap: 4px;
        }

        .reorder-buttons button {
            padding: 2px 8px;
            font-size: 16px;
            line-height: 1;
        }

        .tabs-container {
            background: var(--bg-secondary);
            border-radius: 8px;
            box-shadow: var(--shadow);
            margin-bottom: 20px;
            overflow: hidden;
        }

        .tabs-header {
            display: flex;
            align-items: center;
            border-bottom: 2px solid var(--border-color);
            background: var(--bg-tertiary);
        }

        .tabs {
            display: flex;
            flex: 1;
            overflow-x: auto;
            gap: 2px;
        }

        .tab {
            padding: 12px 20px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            white-space: nowrap;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            position: relative;
        }

        .tab:hover {
            background: rgba(0, 82, 204, 0.05);
            color: var(--text-primary);
        }

        .tab.active {
            color: var(--color-primary);
            background: var(--bg-secondary);
            border-bottom-color: var(--color-primary);
        }

        .tab .tab-close {
            margin-left: 8px;
            color: var(--text-secondary);
            font-weight: bold;
            display: none;
        }

        .tab:hover .tab-close {
            display: inline;
        }

        .tab .tab-close:hover {
            color: #de350b;
        }

        .tab-name {
            cursor: text;
        }

        .tab-rename-input {
            background: var(--bg-secondary);
            border: 1px solid var(--color-primary);
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            outline: none;
            min-width: 100px;
        }

        .tab-actions {
            padding: 8px 12px;
            border-left: 1px solid var(--border-color);
        }

        .tab-actions button {
            padding: 6px 12px;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>
            pioj
            <span class="connection-info">
                <span id="connectionStatus" class="status-indicator disconnected"></span>
                <span id="configStatus"></span>
            </span>
        </h1>
        <button id="themeToggle" class="theme-toggle" onclick="toggleTheme()" title="Toggle dark mode">
            <span class="theme-icon">ðŸŒ™</span>
        </button>
    </div>

    <div class="content-wrapper">
    <div class="tabs-container">
        <div class="tabs-header">
            <div id="tabsContainer" class="tabs"></div>
            <div class="tab-actions">
                <button class="secondary" onclick="openAddPageModal()">+ New Page</button>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="secondary" onclick="openAddWorkstreamModal()">Add Workstream</button>
        <button onclick="refreshAll()">Refresh All</button>
        <button onclick="exportConfiguration()">Export Config</button>
        <button onclick="document.getElementById('importConfigFile').click()">Import Config</button>
        <input type="file" id="importConfigFile" accept=".json" style="display: none;" onchange="importConfiguration(event)">
        <button class="danger" onclick="clearAll()">Clear All Data</button>
    </div>

    <div id="quickNav" class="quick-nav" style="display: none;">
        <h3>Workstreams</h3>
        <div id="quickNavItems" class="quick-nav-items"></div>
    </div>

    <div id="workstreamsContainer" class="workstreams-container"></div>

    <div id="addPageModal" class="modal">
        <div class="modal-content">
            <h2>Add Page</h2>
            <div class="form-group">
                <label for="pageName">Page Name</label>
                <input type="text" id="pageName" placeholder="e.g., Sprint 42, Backend Team, Q1 Planning">
                <div class="help-text">Organize your workstreams into different pages/tabs</div>
            </div>
            <div class="modal-actions">
                <button class="secondary" onclick="closeAddPageModal()">Cancel</button>
                <button onclick="addPage()">Add</button>
            </div>
        </div>
    </div>

    <div id="addWorkstreamModal" class="modal">
        <div class="modal-content">
            <h2>Add Workstream</h2>
            <div class="form-group">
                <label for="workstreamName">Workstream Name</label>
                <input type="text" id="workstreamName" placeholder="e.g., Backend Team Sprint 23">
            </div>
            <div class="form-group">
                <label>Queries</label>
                <div class="help-text">Define multiple queries. Each query executes independently unless you explicitly reference other queries using {query1}, {query2}, etc.</div>
                <div id="queryStackContainer" class="query-stack">
                    <!-- Queries will be rendered here by JavaScript -->
                </div>
                <button type="button" class="add-query-btn" onclick="addQueryToStack()">+ Add Query</button>
            </div>
            <div class="jql-examples">
                <strong>Examples:</strong>
                <code>Q1 (JQL): type = Epic AND project = MYPROJ</code>
                <code>Q2 (FOREACH): FOREACH {query1}: issuekey in childissuesof({issue})</code>
                <code>Q3 (FOREACH): FOREACH {query1}: assignee = "{assignee}"</code>
                <code>Q4 (FOREACH): FOREACH {query1}: reporter = "{reporter}"</code>
                <code>Q5 (Set Operation): {query2} UNION {query3}</code>
                <div style="margin-top: 8px; color: var(--text-secondary); font-size: 11px;">
                    <strong>FOREACH Placeholders:</strong> {issue} {epic} {parent} {assignee} {reporter}
                </div>
            </div>
            <div class="modal-actions">
                <button class="secondary" onclick="closeAddWorkstreamModal()">Cancel</button>
                <button onclick="addWorkstream()">Add</button>
            </div>
        </div>
    </div>

    <div id="markdownExportModal" class="modal">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh; display: flex; flex-direction: column;">
            <h2>ðŸ“„ Markdown Export</h2>
            <div id="markdownContent" style="flex: 1; overflow: auto; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 4px; padding: 15px; font-family: 'Monaco', 'Courier New', monospace; font-size: 13px; line-height: 1.5; white-space: pre-wrap; word-wrap: break-word;"></div>
            <div class="modal-actions" style="margin-top: 15px;">
                <button onclick="downloadMarkdown()">ðŸ’¾ Download .md File</button>
                <button class="secondary" onclick="closeMarkdownExportModal()">Close</button>
            </div>
        </div>
    </div>
    </div>

    <script>
        const API_BASE = '/api';

        let config = {
            host: '',
            llm_configured: false
        };

        let data = {
            pages: [],
            currentPageId: null
        };
        let isConnected = false;
        let modalQueries = []; // Temporary state for modal query editing
        let abortControllers = {}; // Track abort controllers for ongoing refreshes

        function toggleTheme() {
            const body = document.body;
            const themeIcon = document.querySelector('.theme-icon');

            if (body.classList.contains('dark-mode')) {
                body.classList.remove('dark-mode');
                themeIcon.textContent = 'ðŸŒ™';
                localStorage.setItem('theme', 'light');
            } else {
                body.classList.add('dark-mode');
                themeIcon.textContent = 'â˜€ï¸';
                localStorage.setItem('theme', 'dark');
            }
        }

        function loadTheme() {
            const savedTheme = localStorage.getItem('theme');
            const themeIcon = document.querySelector('.theme-icon');

            if (savedTheme === 'dark') {
                document.body.classList.add('dark-mode');
                themeIcon.textContent = 'â˜€ï¸';
            }
        }

        // Migrate workstream from old single-jql format to new queries array format
        function migrateWorkstream(workstream) {
            // Migrate single jql field to queries array if needed
            if (!workstream.queries || !Array.isArray(workstream.queries)) {
                if (workstream.jql) {
                    workstream.queries = [{
                        id: Date.now(),
                        type: 'JQL',
                        jql: workstream.jql,
                        name: undefined
                    }];
                } else {
                    // No jql field, create empty queries array
                    workstream.queries = [];
                }
            }

            // Ensure all queries have a type field (for older migrated data)
            workstream.queries = workstream.queries.map(q => {
                let type = q.type || 'JQL';
                // Migrate old specific operation types to SET_OPERATION
                if (['UNION', 'INTERSECT', 'SUBTRACT', 'XOR'].includes(type)) {
                    type = 'SET_OPERATION';
                }
                return {
                    ...q,
                    type: type
                };
            });

            // Keep the jql field for backward compatibility
            // queryResults starts as undefined (not yet executed)
            if (!workstream.queryResults) {
                workstream.queryResults = undefined;
            }

            return workstream;
        }

        async function init() {
            loadTheme();
            await checkConfig();
            await loadWorkstreams();
            renderTabs();
            renderWorkstreams();
        }

        function getCurrentPage() {
            return data.pages.find(p => p.id === data.currentPageId);
        }

        function getCurrentWorkstreams() {
            const page = getCurrentPage();
            return page ? page.workstreams : [];
        }

        async function checkConfig() {
            const statusDiv = document.getElementById('configStatus');

            try {
                const response = await fetch(`${API_BASE}/config/status`);
                const data = await response.json();

                if (data.configured) {
                    config.host = data.host;
                    config.llm_configured = data.llm_configured || false;
                    isConnected = true;
                    updateConnectionStatus(true);
                    statusDiv.innerHTML = `<span class="jira-host">Connected to JIRA: ${data.host}</span>`;
                } else {
                    config.llm_configured = false;
                    statusDiv.innerHTML = '<span class="jira-error">JIRA not configured. Please create a .env file on the server.</span>';
                    isConnected = false;
                    updateConnectionStatus(false);
                }
            } catch (error) {
                statusDiv.innerHTML = `<div class="error">Error: ${error.message}. Is the server running?</div>`;
                isConnected = false;
                updateConnectionStatus(false);
            }
        }

        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('connectionStatus');
            indicator.className = `status-indicator ${connected ? 'connected' : 'disconnected'}`;
        }

        async function loadWorkstreams() {
            try {
                // First, try to load from localStorage as backup
                const localBackup = localStorage.getItem('workstreams');

                const response = await fetch(`${API_BASE}/workstreams`);
                if (response.ok) {
                    const serverData = await response.json();

                    // Check if data is in new format (with pages)
                    if (serverData.pages && serverData.pages.length > 0) {
                        data = serverData;
                        console.log('Loaded data from server (new format)');
                    } else if (serverData.workstreams && serverData.workstreams.length > 0) {
                        // Migrate old format to new format
                        data.pages = [{
                            id: Date.now(),
                            name: 'Main',
                            workstreams: serverData.workstreams.map(ws => ({
                                ...ws,
                                tickets: ws.tickets || undefined  // Preserve existing tickets or set to undefined
                            }))
                        }];
                        data.currentPageId = data.pages[0].id;
                        await saveWorkstreams();
                        console.log('Migrated old workstreams format to pages');
                    } else if (localBackup) {
                        // Server has no data, try localStorage
                        try {
                            const parsed = JSON.parse(localBackup);

                            // Check if it's in new format
                            if (parsed.pages && parsed.pages.length > 0) {
                                data = parsed;
                                await saveWorkstreams();
                                console.log('Recovered data from localStorage backup (new format)');
                            } else if (Array.isArray(parsed) && parsed.length > 0) {
                                // Old format in localStorage
                                data.pages = [{
                                    id: Date.now(),
                                    name: 'Main',
                                    workstreams: parsed.map(ws => ({
                                        ...ws,
                                        tickets: ws.tickets || undefined
                                    }))
                                }];
                                data.currentPageId = data.pages[0].id;
                                await saveWorkstreams();
                                console.log('Recovered and migrated workstreams from localStorage');
                            }
                        } catch (e) {
                            console.error('Failed to parse localStorage:', e);
                        }
                    }

                    // Ensure we have at least one page
                    if (!data.pages || data.pages.length === 0) {
                        data.pages = [{
                            id: Date.now(),
                            name: 'Main',
                            workstreams: []
                        }];
                        data.currentPageId = data.pages[0].id;
                    }

                    // Ensure workstreams have proper ticket initialization and migrate to new format
                    data.pages.forEach(page => {
                        if (page.workstreams) {
                            page.workstreams = page.workstreams.map(ws => {
                                // Migrate workstream to new queries format
                                ws = migrateWorkstream(ws);
                                // Ensure tickets field exists
                                if (!ws.hasOwnProperty('tickets')) {
                                    ws.tickets = undefined;
                                }
                                return ws;
                            });
                        }
                    });

                    // Ensure currentPageId is valid
                    if (!data.currentPageId || !data.pages.find(p => p.id === data.currentPageId)) {
                        data.currentPageId = data.pages[0].id;
                    }
                } else {
                    console.error('Failed to load workstreams from server');
                    // Try localStorage recovery
                    if (localBackup) {
                        const parsed = JSON.parse(localBackup);
                        if (parsed.pages) {
                            data = parsed;
                        } else if (Array.isArray(parsed)) {
                            data.pages = [{
                                id: Date.now(),
                                name: 'Main',
                                workstreams: parsed
                            }];
                            data.currentPageId = data.pages[0].id;
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading workstreams:', error);
                // Try localStorage as last resort
                try {
                    const localBackup = localStorage.getItem('workstreams');
                    if (localBackup) {
                        const parsed = JSON.parse(localBackup);
                        if (parsed.pages) {
                            data = parsed;
                        } else if (Array.isArray(parsed)) {
                            data.pages = [{
                                id: Date.now(),
                                name: 'Main',
                                workstreams: parsed.map(ws => ({
                                    ...ws,
                                    tickets: ws.tickets || undefined
                                }))
                            }];
                            data.currentPageId = data.pages[0].id;
                        }
                        console.log('Recovered from localStorage after error');
                    }
                } catch (e) {
                    console.error('Failed localStorage recovery:', e);
                }

                // Final fallback
                if (!data.pages || data.pages.length === 0) {
                    data.pages = [{
                        id: Date.now(),
                        name: 'Main',
                        workstreams: []
                    }];
                    data.currentPageId = data.pages[0].id;
                }
            }
        }

        async function saveWorkstreams() {
            // Always save to localStorage first (backup)
            try {
                localStorage.setItem('workstreams', JSON.stringify(data));
                localStorage.setItem('workstreams_backup_' + Date.now(), JSON.stringify(data));

                // Keep only last 5 backups
                const backupKeys = Object.keys(localStorage).filter(k => k.startsWith('workstreams_backup_'));
                if (backupKeys.length > 5) {
                    backupKeys.sort().slice(0, backupKeys.length - 5).forEach(k => localStorage.removeItem(k));
                }
            } catch (e) {
                console.error('Failed to save to localStorage:', e);
            }

            // Save to server
            try {
                const response = await fetch(`${API_BASE}/workstreams`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });

                if (!response.ok) {
                    console.error('Failed to save workstreams to server');
                }
            } catch (error) {
                console.error('Error saving workstreams:', error);
            }
        }

        function openAddPageModal() {
            document.getElementById('addPageModal').classList.add('active');
            document.getElementById('pageName').value = '';
        }

        function closeAddPageModal() {
            document.getElementById('addPageModal').classList.remove('active');
        }

        function addPage() {
            const name = document.getElementById('pageName').value.trim();

            if (!name) {
                alert('Please enter a page name');
                return;
            }

            const newPage = {
                id: Date.now(),
                name: name,
                workstreams: []
            };

            data.pages.push(newPage);
            data.currentPageId = newPage.id;

            saveWorkstreams();
            closeAddPageModal();
            renderTabs();
            renderWorkstreams();
        }

        function switchPage(pageId) {
            data.currentPageId = pageId;
            saveWorkstreams();
            renderTabs();
            renderWorkstreams();
        }

        function deletePage(pageId, event) {
            event.stopPropagation();

            if (data.pages.length === 1) {
                alert('Cannot delete the last page');
                return;
            }

            const page = data.pages.find(p => p.id === pageId);
            if (page && page.workstreams.length > 0) {
                if (!confirm(`Delete page "${page.name}" and its ${page.workstreams.length} workstream(s)?`)) {
                    return;
                }
            }

            data.pages = data.pages.filter(p => p.id !== pageId);

            if (data.currentPageId === pageId) {
                data.currentPageId = data.pages[0].id;
            }

            saveWorkstreams();
            renderTabs();
            renderWorkstreams();
        }

        function renderTabs() {
            const container = document.getElementById('tabsContainer');

            container.innerHTML = data.pages.map(page => `
                <button class="tab ${page.id === data.currentPageId ? 'active' : ''}" data-page-id="${page.id}">
                    <span class="tab-name">${escapeHtml(page.name)}</span>
                    ${data.pages.length > 1 ? `<span class="tab-close" onclick="deletePage(${page.id}, event)">Ã—</span>` : ''}
                </button>
            `).join('');

            // Attach event listeners after rendering
            container.querySelectorAll('.tab').forEach(tab => {
                const pageId = parseInt(tab.getAttribute('data-page-id'));
                const tabName = tab.querySelector('.tab-name');
                const tabClose = tab.querySelector('.tab-close');

                let clickTimeout = null;

                // Click to switch page (with delay to allow double-click)
                tab.addEventListener('click', (e) => {
                    // Don't switch if clicking close button
                    if (tabClose && (e.target === tabClose || tabClose.contains(e.target))) return;

                    // If clicking on the tab name, use a delay to allow double-click
                    if (tabName && (e.target === tabName || tabName.contains(e.target))) {
                        // Clear any pending click
                        if (clickTimeout) clearTimeout(clickTimeout);

                        // Wait a bit to see if this is a double-click
                        clickTimeout = setTimeout(() => {
                            if (data.currentPageId !== pageId) {
                                switchPage(pageId);
                            }
                        }, 250);
                    } else {
                        // Clicking elsewhere on tab, switch immediately
                        if (data.currentPageId !== pageId) {
                            switchPage(pageId);
                        }
                    }
                });

                // Double-click name to rename
                if (tabName) {
                    tabName.addEventListener('dblclick', (e) => {
                        e.preventDefault();
                        // Cancel the pending single-click
                        if (clickTimeout) {
                            clearTimeout(clickTimeout);
                            clickTimeout = null;
                        }
                        startRenamePage(pageId, tabName);
                    });
                }
            });
        }

        function startRenamePage(pageId, spanElement) {
            const page = data.pages.find(p => p.id === pageId);
            if (!page) return;

            const span = spanElement;
            const currentName = page.name;

            // Create input element
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'tab-rename-input';
            input.value = currentName;

            // Replace span with input
            span.replaceWith(input);
            input.focus();
            input.select();

            // Handle finishing rename
            const finishRename = () => {
                const newName = input.value.trim();

                if (newName && newName !== currentName) {
                    page.name = newName;
                    saveWorkstreams();
                }

                renderTabs();
            };

            // Finish on blur or Enter key
            input.addEventListener('blur', finishRename);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    finishRename();
                } else if (e.key === 'Escape') {
                    renderTabs(); // Cancel rename
                }
            });

            // Prevent switching pages when clicking input
            input.addEventListener('click', (e) => e.stopPropagation());
        }

        // Modal Query Management Functions
        function initializeModalQueries(queries) {
            if (queries && queries.length > 0) {
                modalQueries = JSON.parse(JSON.stringify(queries)); // Deep copy
                // Ensure all queries have a type
                modalQueries = modalQueries.map(q => ({
                    ...q,
                    type: q.type || 'JQL'
                }));
            } else {
                // Initialize with one empty query
                modalQueries = [{
                    id: Date.now(),
                    type: 'JQL',
                    jql: '',
                    name: undefined
                }];
            }
            renderModalQueries();
        }

        function renderModalQueries() {
            const container = document.getElementById('queryStackContainer');
            if (!container) return;

            container.innerHTML = modalQueries.map((query, index) => {
                const queryType = query.type || 'JQL';
                const isJQL = queryType === 'JQL';
                const isSetOp = queryType === 'SET_OPERATION';

                // Generate placeholder text based on type
                let placeholder = '';
                let helpText = '';
                if (isJQL) {
                    placeholder = 'Enter JQL query (e.g., project = MYPROJ)';
                    helpText = 'Independent query. Reference other queries with {query1}, {query2}, etc. (e.g., key in ({query1}))';
                } else if (queryType === 'FOREACH') {
                    placeholder = 'FOREACH {query1}: issuekey in childissuesof({issue})';
                    helpText = 'Iterate over unique values from referenced query. Placeholders: {issue}, {epic}, {parent}, {assignee}, {reporter}. Results are combined.';
                } else if (queryType === 'SET_OPERATION') {
                    placeholder = '{query1} UNION {query2}';
                    helpText = 'Combine queries using: UNION (all), INTERSECT (common), SUBTRACT (difference), XOR (exclusive). Works with explicit keys: {query1} SUBTRACT (ISSUE-1, ISSUE-2)';
                }

                // Generate reference buttons for previous queries
                let referenceButtons = '';
                if (index > 0) {
                    const refs = [];
                    for (let i = 0; i < index; i++) {
                        refs.push(`<button type="button" class="query-ref-btn" onclick="insertQueryReference(${index}, ${i + 1})" title="Insert reference to Query ${i + 1}">{query${i + 1}}</button>`);
                    }
                    referenceButtons = `<div class="query-ref-buttons">${refs.join('')}</div>`;
                }

                // Generate placeholder buttons for FOREACH queries
                let placeholderButtons = '';
                if (queryType === 'FOREACH') {
                    placeholderButtons = `
                        <div class="query-ref-buttons">
                            <button type="button" class="query-placeholder-btn" onclick="insertForeachPlaceholder(${index}, 'issue')" title="Insert {issue} placeholder">{issue}</button>
                            <button type="button" class="query-placeholder-btn" onclick="insertForeachPlaceholder(${index}, 'epic')" title="Insert {epic} placeholder">{epic}</button>
                            <button type="button" class="query-placeholder-btn" onclick="insertForeachPlaceholder(${index}, 'parent')" title="Insert {parent} placeholder">{parent}</button>
                            <button type="button" class="query-placeholder-btn" onclick="insertForeachPlaceholder(${index}, 'assignee')" title="Insert {assignee} placeholder">{assignee}</button>
                            <button type="button" class="query-placeholder-btn" onclick="insertForeachPlaceholder(${index}, 'reporter')" title="Insert {reporter} placeholder">{reporter}</button>
                        </div>
                    `;
                } else if (queryType === 'SET_OPERATION') {
                    placeholderButtons = `
                        <div class="query-ref-buttons">
                            <button type="button" class="query-placeholder-btn" onclick="insertSetOperation(${index}, 'UNION')" title="Insert UNION operator">UNION</button>
                            <button type="button" class="query-placeholder-btn" onclick="insertSetOperation(${index}, 'INTERSECT')" title="Insert INTERSECT operator">INTERSECT</button>
                            <button type="button" class="query-placeholder-btn" onclick="insertSetOperation(${index}, 'SUBTRACT')" title="Insert SUBTRACT operator">SUBTRACT</button>
                            <button type="button" class="query-placeholder-btn" onclick="insertSetOperation(${index}, 'XOR')" title="Insert XOR operator">XOR</button>
                        </div>
                    `;
                }

                return `
                <div class="query-item">
                    <div class="query-header">
                        <span class="query-number">Query ${index + 1}</span>
                        <div class="query-actions">
                            <button type="button" onclick="moveQuery(${index}, -1)" ${index === 0 ? 'disabled' : ''} title="Move up">â†‘</button>
                            <button type="button" onclick="moveQuery(${index}, 1)" ${index === modalQueries.length - 1 ? 'disabled' : ''} title="Move down">â†“</button>
                            <button type="button" onclick="removeQuery(${index})" ${modalQueries.length === 1 ? 'disabled' : ''} title="Remove">Ã—</button>
                        </div>
                    </div>
                    <select class="query-type-select" onchange="updateQueryType(${index}, this.value)">
                        <option value="JQL" ${queryType === 'JQL' ? 'selected' : ''}>JQL Query</option>
                        <option value="FOREACH" ${queryType === 'FOREACH' ? 'selected' : ''}>FOREACH</option>
                        <option value="SET_OPERATION" ${queryType === 'SET_OPERATION' ? 'selected' : ''}>Set Operation</option>
                    </select>
                    <input
                        type="text"
                        class="query-name-input"
                        placeholder="Optional: Query name (e.g., 'Backend tickets')"
                        value="${escapeHtml(query.name || '')}"
                        onchange="updateQueryName(${index}, this.value)"
                    />
                    ${referenceButtons}
                    ${placeholderButtons}
                    <textarea
                        id="query-jql-${index}"
                        class="query-jql-textarea"
                        placeholder="${escapeHtml(placeholder)}"
                        onchange="updateQueryJql(${index}, this.value)"
                    >${escapeHtml(query.jql || '')}</textarea>
                    <div class="query-help-text">${escapeHtml(helpText)}</div>
                </div>
            `;
            }).join('');
        }

        function addQueryToStack() {
            modalQueries.push({
                id: Date.now(),
                type: 'JQL',
                jql: '',
                name: undefined
            });
            renderModalQueries();
        }

        function removeQuery(index) {
            if (modalQueries.length <= 1) {
                alert('You must have at least one query');
                return;
            }
            modalQueries.splice(index, 1);
            renderModalQueries();
        }

        function moveQuery(index, direction) {
            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= modalQueries.length) {
                return;
            }
            // Swap queries
            const temp = modalQueries[index];
            modalQueries[index] = modalQueries[newIndex];
            modalQueries[newIndex] = temp;
            renderModalQueries();
        }

        function updateQueryName(index, value) {
            modalQueries[index].name = value.trim() || undefined;
        }

        function updateQueryType(index, value) {
            modalQueries[index].type = value;
            renderModalQueries();  // Re-render to update placeholder/helpers
        }

        function updateQueryJql(index, value) {
            modalQueries[index].jql = value.trim();
        }

        function insertQueryReference(queryIndex, refNumber) {
            const textarea = document.getElementById(`query-jql-${queryIndex}`);
            if (textarea) {
                const cursorPos = textarea.selectionStart;
                const textBefore = textarea.value.substring(0, cursorPos);
                const textAfter = textarea.value.substring(cursorPos);
                const newValue = textBefore + `{query${refNumber}}` + textAfter;
                textarea.value = newValue;
                updateQueryJql(queryIndex, newValue);
                // Set cursor after inserted text
                textarea.focus();
                textarea.setSelectionRange(cursorPos + `{query${refNumber}}`.length, cursorPos + `{query${refNumber}}`.length);
            }
        }

        function insertForeachPlaceholder(queryIndex, placeholder) {
            const textarea = document.getElementById(`query-jql-${queryIndex}`);
            if (textarea) {
                const cursorPos = textarea.selectionStart;
                const textBefore = textarea.value.substring(0, cursorPos);
                const textAfter = textarea.value.substring(cursorPos);
                const placeholderText = `{${placeholder}}`;
                const newValue = textBefore + placeholderText + textAfter;
                textarea.value = newValue;
                updateQueryJql(queryIndex, newValue);
                // Set cursor after inserted text
                textarea.focus();
                textarea.setSelectionRange(cursorPos + placeholderText.length, cursorPos + placeholderText.length);
            }
        }

        function insertSetOperation(queryIndex, operation) {
            const textarea = document.getElementById(`query-jql-${queryIndex}`);
            if (textarea) {
                const cursorPos = textarea.selectionStart;
                const textBefore = textarea.value.substring(0, cursorPos);
                const textAfter = textarea.value.substring(cursorPos);
                const operationText = ` ${operation} `;
                const newValue = textBefore + operationText + textAfter;
                textarea.value = newValue;
                updateQueryJql(queryIndex, newValue);
                // Set cursor after inserted text
                textarea.focus();
                textarea.setSelectionRange(cursorPos + operationText.length, cursorPos + operationText.length);
            }
        }

        function openAddWorkstreamModal() {
            document.getElementById('addWorkstreamModal').classList.add('active');
            document.getElementById('workstreamName').value = '';
            // Initialize with one empty query
            initializeModalQueries([]);
        }

        function closeAddWorkstreamModal() {
            document.getElementById('addWorkstreamModal').classList.remove('active');
            modalQueries = []; // Clear modal state
        }

        function addWorkstream() {
            const name = document.getElementById('workstreamName').value.trim();

            if (!name) {
                alert('Please enter a workstream name');
                return;
            }

            // Validate queries
            const validQueries = modalQueries.filter(q => q.jql && q.jql.trim());
            if (validQueries.length === 0) {
                alert('Please enter at least one query');
                return;
            }

            const page = getCurrentPage();
            if (!page) {
                alert('No page selected');
                return;
            }

            // Create workstream with new queries format
            const workstream = {
                id: Date.now(),
                name: name,
                queries: validQueries.map(q => ({
                    id: q.id,
                    type: q.type || 'JQL',
                    jql: q.jql.trim(),
                    name: q.name
                })),
                queryResults: undefined,
                tickets: undefined
            };

            // For backward compatibility, also set jql field to first query
            if (validQueries.length > 0) {
                workstream.jql = validQueries[0].jql.trim();
            }

            page.workstreams.push(workstream);

            saveWorkstreams();
            closeAddWorkstreamModal();
            renderWorkstreams();
            refreshWorkstream(page.workstreams.length - 1);
        }

        function deleteWorkstream(index) {
            const page = getCurrentPage();
            if (!page) return;

            if (confirm('Are you sure you want to delete this workstream?')) {
                page.workstreams.splice(index, 1);
                saveWorkstreams();
                renderWorkstreams();
            }
        }

        function renderWorkstreams() {
            const container = document.getElementById('workstreamsContainer');
            const quickNav = document.getElementById('quickNav');
            const quickNavItems = document.getElementById('quickNavItems');

            const page = getCurrentPage();
            if (!page) {
                container.innerHTML = '<div class="empty-state"><h3>No page selected</h3></div>';
                quickNav.style.display = 'none';
                return;
            }

            const workstreams = page.workstreams;

            if (workstreams.length === 0) {
                container.innerHTML = '<div class="empty-state"><h3>No workstreams defined</h3><p>Click "Add Workstream" to get started</p></div>';
                quickNav.style.display = 'none';
                return;
            }

            // Render quick navigation
            quickNav.style.display = 'block';
            quickNavItems.innerHTML = workstreams.map((ws, index) => `
                <a href="#workstream-${ws.id}" class="quick-nav-item">
                    ${escapeHtml(ws.name)}
                    ${ws.tickets !== undefined ? `<span class="count">(${ws.tickets.length})</span>` : ''}
                </a>
            `).join('');

            // Render workstreams
            container.innerHTML = workstreams.map((ws, index) => {
                let ticketStats = '';
                if (ws.tickets && ws.tickets.length > 0) {
                    const total = ws.tickets.length;
                    const done = ws.tickets.filter(t => t.statusCategory === 'done').length;
                    const percentage = Math.round((done / total) * 100);
                    ticketStats = `<span class="ticket-count">${total} tickets â€¢ ${percentage}% done</span>`;
                }

                return `
                <div class="swimlane" id="workstream-${ws.id}">
                    <div class="swimlane-header">
                        <h3>
                            ${escapeHtml(ws.name)}
                            ${ticketStats}
                        </h3>
                        <div class="swimlane-controls">
                            <div class="reorder-buttons">
                                <button onclick="moveWorkstream(${index}, -1)" ${index === 0 ? 'disabled' : ''} title="Move up">â†‘</button>
                                <button onclick="moveWorkstream(${index}, 1)" ${index === workstreams.length - 1 ? 'disabled' : ''} title="Move down">â†“</button>
                            </div>
                            <button id="refresh-btn-${index}" onclick="refreshWorkstream(${index})">Refresh</button>
                            <button id="cancel-btn-${index}" onclick="cancelWorkstreamRefresh(${index})" style="display: none; background: #de350b; color: white;">Cancel</button>
                            <button onclick="exportWorkstream(${index})">Export CSV</button>
                            <button onclick="editWorkstream(${index})">Edit</button>
                            <button onclick="deleteWorkstream(${index})">Delete</button>
                        </div>
                    </div>
                    <div class="swimlane-body">
                        <div class="swimlane-config">
                            <div class="queries-display">
                                ${(ws.queries || []).map((query, qIdx) => `
                                    <div class="query-display-item">
                                        <div class="query-display-header">
                                            <strong>Query ${qIdx + 1}${query.name ? ': ' + escapeHtml(query.name) : ''}</strong>
                                            <span class="query-type-badge">${getQueryTypeLabel(query)}</span>
                                        </div>
                                        <span class="query-equals">=</span>
                                        <textarea readonly>${escapeHtml(query.jql)}</textarea>
                                    </div>
                                `).join('')}
                            </div>
                            <div class="grouping-options">
                                <div class="view-toggle">
                                    <button class="${!ws.view || ws.view === 'cards' ? 'active' : ''}" onclick="setView(${index}, 'cards')">Cards</button>
                                    <button class="${ws.view === 'compact' ? 'active' : ''}" onclick="setView(${index}, 'compact')">Table</button>
                                    <button class="${ws.view === 'tree' ? 'active' : ''}" onclick="setView(${index}, 'tree')">Tree</button>
                                </div>
                                <div class="group-by-options ${ws.view === 'tree' ? 'hidden' : ''}">
                                    <div class="group-by-toggle">
                                        <input type="checkbox" id="groupByEpic-${index}" ${ws.groupBy === 'epic' ? 'checked' : ''} onchange="toggleGroupBy(${index}, 'epic')">
                                        <label for="groupByEpic-${index}">Group by Epic</label>
                                    </div>
                                    <div class="group-by-toggle">
                                        <input type="checkbox" id="groupByParent-${index}" ${ws.groupBy === 'parent' ? 'checked' : ''} onchange="toggleGroupBy(${index}, 'parent')">
                                        <label for="groupByParent-${index}">Group by Parent Link</label>
                                    </div>
                                    <div class="group-by-toggle">
                                        <input type="checkbox" id="groupByAssignee-${index}" ${ws.groupBy === 'assignee' ? 'checked' : ''} onchange="toggleGroupBy(${index}, 'assignee')">
                                        <label for="groupByAssignee-${index}">Group by Assignee</label>
                                    </div>
                                </div>
                                <div class="tree-controls ${ws.view === 'tree' ? '' : 'hidden'}">
                                    <button onclick="expandAllTreeNodes()" class="tree-control-button">Expand All</button>
                                    <button onclick="collapseAllTreeNodes()" class="tree-control-button">Collapse All</button>
                                </div>
                            </div>
                        </div>
                        ${ws.summary ? `
                            <div class="workstream-summary">
                                <div class="summary-header">
                                    <h4>ðŸ“ AI Summary (Last ${ws.summary.days} days)</h4>
                                    <div class="summary-meta">
                                        <span>${ws.summary.changeCount} changes â€¢ Generated ${formatTimestamp(ws.summary.generatedAt)}</span>
                                        <button onclick="generateSummary(${index})" class="summary-regenerate" ${!config.llm_configured ? 'disabled title="LLM not configured. See .env.example for setup instructions."' : ''}>ðŸ”„ Regenerate</button>
                                    </div>
                                </div>
                                <div class="summary-content">${ws.summary.text}</div>
                            </div>
                        ` : ''}
                        <div id="workstream-content-${index}">
                            ${
                                ws.tickets === undefined
                                    ? '<div class="empty-state">Click Refresh to load tickets</div>'
                                    : renderWorkstreamContent(ws, index)
                            }
                        </div>
                        ${ws.lastUpdated ? `<div class="last-updated">Last updated: ${formatTimestamp(ws.lastUpdated)}</div>` : ''}
                        ${ws.tickets && ws.tickets.length > 0 ? `
                            <div class="workstream-analysis-box">
                                <div class="analysis-box-controls">
                                    <h4>ðŸ¤– AI Analysis</h4>
                                    <select id="summary-days-${index}" onchange="handleTimeRangeChange(${index})">
                                        <option value="1">Last 24h</option>
                                        <option value="3">Last 3 days</option>
                                        <option value="7" selected>Last 7 days</option>
                                        <option value="14">Last 14 days</option>
                                        <option value="custom">Custom...</option>
                                    </select>
                                    <input type="number" id="custom-days-${index}" class="custom-days-input" style="display: none;" placeholder="Days" min="1" max="365" />
                                    <label class="checkbox-label">
                                        <input type="checkbox" id="omit-inactive-${index}" />
                                        <span>Omit tickets with no activity</span>
                                    </label>
                                    <button onclick="exportWorkstreamMarkdown(${index})">ðŸ“„ Export Markdown</button>
                                    <button onclick="generateSummary(${index})" ${!config.llm_configured ? 'disabled title="LLM not configured. See .env.example for setup instructions."' : ''}>ðŸ¤– Get Summary</button>
                                    <button onclick="toggleContextInput(${index})" class="secondary" ${!config.llm_configured ? 'disabled title="LLM not configured. See .env.example for setup instructions."' : ''}>âž• Add Context</button>
                                </div>
                                <div id="context-input-${index}" class="context-input" style="display: none;">
                                    <label for="summary-context-${index}">Additional context for AI analysis:</label>
                                    <textarea id="summary-context-${index}" placeholder="E.g., Focus on security issues, ignore minor UI changes, etc." rows="2"></textarea>
                                </div>
                                <div id="export-progress-${index}" class="export-progress" style="display: none;">
                                    <div class="progress-info">
                                        <span id="export-status-${index}">Preparing export...</span>
                                        <span id="export-percentage-${index}">0%</span>
                                    </div>
                                    <div class="progress-bar-container">
                                        <div id="export-progress-bar-${index}" class="progress-bar"></div>
                                    </div>
                                </div>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
            }).join('');
        }

        function editWorkstream(index) {
            const page = getCurrentPage();
            if (!page) return;

            const ws = page.workstreams[index];

            // Open modal first
            document.getElementById('addWorkstreamModal').classList.add('active');

            // Then set values (after modal is opened)
            document.getElementById('workstreamName').value = ws.name;

            // Load existing queries into modal
            initializeModalQueries(ws.queries || []);

            const modal = document.getElementById('addWorkstreamModal');
            const title = modal.querySelector('h2');
            const addButton = modal.querySelector('.modal-actions button:last-child');

            title.textContent = 'Edit Workstream';
            addButton.textContent = 'Update';
            addButton.onclick = () => {
                const name = document.getElementById('workstreamName').value.trim();

                if (!name) {
                    alert('Please enter a workstream name');
                    return;
                }

                // Validate queries
                const validQueries = modalQueries.filter(q => q.jql && q.jql.trim());
                if (validQueries.length === 0) {
                    alert('Please enter at least one query');
                    return;
                }

                ws.name = name;
                ws.queries = validQueries.map(q => ({
                    id: q.id,
                    type: q.type || 'JQL',
                    jql: q.jql.trim(),
                    name: q.name
                }));

                // For backward compatibility, update jql field
                ws.jql = validQueries[0].jql.trim();

                // Clear query results to force re-execution
                ws.queryResults = undefined;
                ws.tickets = undefined;

                saveWorkstreams();
                closeAddWorkstreamModal();
                renderWorkstreams();

                title.textContent = 'Add Workstream';
                addButton.textContent = 'Add';
                addButton.onclick = addWorkstream;
            };
        }

        // Set operation helper functions
        function unionTickets(tickets1, tickets2) {
            const ticketMap = new Map();
            [...tickets1, ...tickets2].forEach(ticket => {
                ticketMap.set(ticket.key, ticket);
            });
            return Array.from(ticketMap.values());
        }

        function intersectTickets(tickets1, tickets2) {
            const keys2 = new Set(tickets2.map(t => t.key));
            return tickets1.filter(t => keys2.has(t.key));
        }

        function subtractTickets(tickets1, tickets2) {
            const keys2 = new Set(tickets2.map(t => t.key));
            return tickets1.filter(t => !keys2.has(t.key));
        }

        function xorTickets(tickets1, tickets2) {
            const keys1 = new Set(tickets1.map(t => t.key));
            const keys2 = new Set(tickets2.map(t => t.key));
            const inOnly1 = tickets1.filter(t => !keys2.has(t.key));
            const inOnly2 = tickets2.filter(t => !keys1.has(t.key));
            return [...inOnly1, ...inOnly2];
        }

        // Parse DSL expression like "{query1} UNION {query2}" or "{query1} SUBTRACT (ISSUE-1, ISSUE-2)"
        function parseDSLExpression(expression) {
            // Pattern matches: {queryN} or (KEY1, KEY2, ...) on both sides
            const pattern = /(?:\{query(\d+)\}|\(([\w\-,\s]+)\))\s+(UNION|INTERSECT|SUBTRACT|XOR)\s+(?:\{query(\d+)\}|\(([\w\-,\s]+)\))/i;
            const match = expression.match(pattern);

            if (!match) {
                throw new Error('Invalid DSL syntax. Expected: {query1} OPERATION {query2} or {query1} OPERATION (ISSUE-1, ISSUE-2)');
            }

            return {
                leftQueryIndex: match[1] ? parseInt(match[1]) - 1 : null,
                leftKeys: match[2] ? match[2].split(',').map(k => k.trim()).filter(k => k) : null,
                operation: match[3].toUpperCase(),
                rightQueryIndex: match[4] ? parseInt(match[4]) - 1 : null,
                rightKeys: match[5] ? match[5].split(',').map(k => k.trim()).filter(k => k) : null
            };
        }

        // Parse FOREACH expression like "FOREACH {query1}: issuekey in childissuesof({issue})"
        // Supports: {issue}, {epic}, {parent}, {assignee}, {status}, {priority}, {type}
        function parseForeachExpression(expression) {
            const pattern = /FOREACH\s+\{query(\d+)\}\s*:\s*(.+)/i;
            const match = expression.match(pattern);

            if (!match) {
                throw new Error('Invalid FOREACH syntax. Expected: FOREACH {queryN}: <jql with placeholder>');
            }

            const jqlTemplate = match[2].trim();

            // Detect which placeholder is being used (check in priority order)
            let iteratorType = 'issue'; // default
            if (jqlTemplate.includes('{assignee}')) {
                iteratorType = 'assignee';
            } else if (jqlTemplate.includes('{reporter}')) {
                iteratorType = 'reporter';
            } else if (jqlTemplate.includes('{epic}')) {
                iteratorType = 'epic';
            } else if (jqlTemplate.includes('{parent}')) {
                iteratorType = 'parent';
            }

            return {
                queryIndex: parseInt(match[1]) - 1,
                jqlTemplate: jqlTemplate,
                iteratorType: iteratorType
            };
        }

        // Get display label for query type (parses SET_OPERATION to show specific operation)
        function getQueryTypeLabel(query) {
            const type = query.type || 'JQL';
            if (type === 'SET_OPERATION') {
                try {
                    const parsed = parseDSLExpression(query.jql);
                    return parsed.operation; // Returns UNION, INTERSECT, SUBTRACT, or XOR
                } catch (e) {
                    return 'Set Operation';
                }
            }
            return type;
        }

        // Execute a DSL operation
        async function executeDSLOperation(query, queryResults, signal = null) {
            const parsed = parseDSLExpression(query.jql);

            // Get left operand tickets
            let leftTickets;
            if (parsed.leftQueryIndex !== null) {
                if (parsed.leftQueryIndex < 0 || parsed.leftQueryIndex >= queryResults.length) {
                    throw new Error(`Query ${parsed.leftQueryIndex + 1} not found`);
                }
                leftTickets = queryResults[parsed.leftQueryIndex].tickets;
            } else if (parsed.leftKeys) {
                // Fetch tickets by keys
                leftTickets = await fetchTickets(parsed.leftKeys.join(', '), false, signal);
            } else {
                throw new Error('Invalid left operand');
            }

            // Get right operand tickets
            let rightTickets;
            if (parsed.rightQueryIndex !== null) {
                if (parsed.rightQueryIndex < 0 || parsed.rightQueryIndex >= queryResults.length) {
                    throw new Error(`Query ${parsed.rightQueryIndex + 1} not found`);
                }
                rightTickets = queryResults[parsed.rightQueryIndex].tickets;
            } else if (parsed.rightKeys) {
                // Fetch tickets by keys
                rightTickets = await fetchTickets(parsed.rightKeys.join(', '), false, signal);
            } else {
                throw new Error('Invalid right operand');
            }

            // Perform the operation
            switch (parsed.operation) {
                case 'UNION':
                    return unionTickets(leftTickets, rightTickets);
                case 'INTERSECT':
                    return intersectTickets(leftTickets, rightTickets);
                case 'SUBTRACT':
                    return subtractTickets(leftTickets, rightTickets);
                case 'XOR':
                    return xorTickets(leftTickets, rightTickets);
                default:
                    throw new Error(`Unknown operation: ${parsed.operation}`);
            }
        }

        // Execute a FOREACH operation
        async function executeForeachOperation(query, queryResults, signal = null) {
            const parsed = parseForeachExpression(query.jql);

            // Get the source query
            if (parsed.queryIndex < 0 || parsed.queryIndex >= queryResults.length) {
                throw new Error(`Query ${parsed.queryIndex + 1} not found`);
            }

            const sourceTickets = queryResults[parsed.queryIndex].tickets;

            if (sourceTickets.length === 0) {
                return []; // No tickets to iterate over
            }

            // Determine what to iterate over based on iterator type
            let itemsToIterate = [];
            let placeholderPattern;

            if (parsed.iteratorType === 'epic') {
                // Extract unique epic keys
                const epicKeys = new Set();
                sourceTickets.forEach(ticket => {
                    if (ticket.epicKey) {
                        epicKeys.add(ticket.epicKey);
                    }
                });
                itemsToIterate = Array.from(epicKeys);
                placeholderPattern = /\{epic\}/g;
                console.log(`  FOREACH over ${itemsToIterate.length} unique epics from ${sourceTickets.length} tickets`);
            } else if (parsed.iteratorType === 'parent') {
                // Extract unique parent keys
                const parentKeys = new Set();
                sourceTickets.forEach(ticket => {
                    if (ticket.parentKey) {
                        parentKeys.add(ticket.parentKey);
                    }
                });
                itemsToIterate = Array.from(parentKeys);
                placeholderPattern = /\{parent\}/g;
                console.log(`  FOREACH over ${itemsToIterate.length} unique parents from ${sourceTickets.length} tickets`);
            } else if (parsed.iteratorType === 'assignee') {
                // Extract unique assignees
                const assignees = new Set();
                sourceTickets.forEach(ticket => {
                    if (ticket.assignee && ticket.assignee !== 'Unassigned') {
                        assignees.add(ticket.assignee);
                    }
                });
                itemsToIterate = Array.from(assignees);
                placeholderPattern = /\{assignee\}/g;
                console.log(`  FOREACH over ${itemsToIterate.length} unique assignees from ${sourceTickets.length} tickets`);
            } else if (parsed.iteratorType === 'reporter') {
                // Extract unique reporters
                const reporters = new Set();
                sourceTickets.forEach(ticket => {
                    if (ticket.reporter && ticket.reporter !== 'Unknown') {
                        reporters.add(ticket.reporter);
                    }
                });
                itemsToIterate = Array.from(reporters);
                placeholderPattern = /\{reporter\}/g;
                console.log(`  FOREACH over ${itemsToIterate.length} unique reporters from ${sourceTickets.length} tickets`);
            } else {
                // Default: iterate over ticket keys
                itemsToIterate = sourceTickets.map(t => t.key);
                placeholderPattern = /\{issue\}/g;
                console.log(`  FOREACH over ${itemsToIterate.length} ticket keys`);
            }

            if (itemsToIterate.length === 0) {
                console.log(`  No ${parsed.iteratorType} to iterate over`);
                return [];
            }

            // Warn if iterating over many items
            if (itemsToIterate.length > 50) {
                console.warn(`FOREACH iterating over ${itemsToIterate.length} ${parsed.iteratorType} - this may take a while`);
            }

            // Execute JQL for each item
            const ticketMap = new Map(); // For deduplication

            for (const item of itemsToIterate) {
                // Replace placeholder with the current item
                const jql = parsed.jqlTemplate.replace(placeholderPattern, item);
                console.log(`  FOREACH iteration for ${item}: ${jql}`);

                try {
                    const results = await fetchTickets(jql, true, signal); // Force JQL for FOREACH
                    console.log(`  â†’ ${results.length} tickets found`);
                    // Add to map for deduplication
                    results.forEach(t => ticketMap.set(t.key, t));
                } catch (error) {
                    console.error(`FOREACH error for ${item}:`, error);
                    // Re-throw abort errors
                    if (error.name === 'AbortError') throw error;
                    // Continue with next item for other errors
                }
            }

            return Array.from(ticketMap.values());
        }

        async function refreshWorkstream(index) {
            const page = getCurrentPage();
            if (!page) return;

            const workstream = page.workstreams[index];
            const container = document.getElementById(`workstream-content-${index}`);

            if (!isConnected) {
                container.innerHTML = '<div class="error">Please connect to JIRA first</div>';
                return;
            }

            // Create abort controller for this refresh
            const abortController = new AbortController();
            abortControllers[index] = abortController;

            // Show cancel button, hide refresh button
            const refreshBtn = document.getElementById(`refresh-btn-${index}`);
            const cancelBtn = document.getElementById(`cancel-btn-${index}`);
            if (refreshBtn) refreshBtn.style.display = 'none';
            if (cancelBtn) cancelBtn.style.display = 'inline-block';

            container.innerHTML = '<div class="loading"><span class="loading-with-spinner"><div class="spinner"></div>Loading tickets...</span></div>';

            try {
                // Execute queries independently (no automatic stacking)
                const queries = workstream.queries || [];
                if (queries.length === 0) {
                    delete abortControllers[index];
                    container.innerHTML = '<div class="error">No queries defined</div>';
                    return;
                }

                const queryResults = [];

                // Initialize all queries with pending state
                workstream.queryResults = queries.map(q => ({ loading: false, pending: true }));
                container.innerHTML = renderWorkstreamContent(workstream, index);

                for (let i = 0; i < queries.length; i++) {
                    const query = queries[i];
                    const queryType = query.type || 'JQL';
                    const startTime = Date.now();
                    let tickets;
                    let processedJql = query.jql;

                    // Mark this query as loading
                    queryResults[i] = { loading: true };
                    workstream.queryResults = queryResults;
                    container.innerHTML = renderWorkstreamContent(workstream, index);

                    try {
                        if (queryType === 'JQL') {
                            // Handle JQL query with string substitution
                            // Replace {query1}, {query2}, etc. with ticket keys
                            processedJql = query.jql;
                            for (let j = 0; j < i; j++) {
                                if (queryResults[j] && queryResults[j].tickets) {
                                    const refTickets = queryResults[j].tickets;
                                    const keys = refTickets.map(t => t.key).join(', ');
                                    // Replace all occurrences of {queryN}
                                    const regex = new RegExp(`\\{query${j + 1}\\}`, 'g');
                                    processedJql = processedJql.replace(regex, keys);
                                }
                            }

                            console.log(`[Query ${i + 1}] JQL:`, processedJql);
                            tickets = await fetchTickets(processedJql, true, abortController.signal); // Force JQL for JQL type queries
                            console.log(`[Query ${i + 1}] Result: ${tickets.length} tickets`);
                        } else if (queryType === 'FOREACH') {
                            // Handle foreach operations
                            console.log(`[Query ${i + 1}] FOREACH:`, query.jql);
                            tickets = await executeForeachOperation(query, queryResults, abortController.signal);
                            console.log(`[Query ${i + 1}] Result: ${tickets.length} tickets`);
                            processedJql = query.jql; // Keep original for display
                        } else if (queryType === 'SET_OPERATION') {
                            // Handle set operations (UNION, INTERSECT, SUBTRACT, XOR)
                            console.log(`[Query ${i + 1}] Set Operation:`, query.jql);
                            tickets = await executeDSLOperation(query, queryResults, abortController.signal);
                            console.log(`[Query ${i + 1}] Result: ${tickets.length} tickets`);
                        } else {
                            throw new Error(`Unknown query type: ${queryType}`);
                        }

                        const executionTime = Date.now() - startTime;

                        // Store results
                        queryResults[i] = {
                            queryId: query.id,
                            queryType: queryType,
                            queryName: query.name,
                            queryJql: query.jql,
                            processedJql: processedJql,
                            tickets: tickets,
                            count: tickets.length,
                            executionTime: executionTime
                        };

                    } catch (error) {
                        // Store error result
                        queryResults[i] = {
                            queryId: query.id,
                            queryType: queryType,
                            queryName: query.name,
                            queryJql: query.jql,
                            processedJql: processedJql,
                            tickets: [],
                            count: 0,
                            executionTime: Date.now() - startTime,
                            error: error.message
                        };
                        // Don't stop execution on error - continue with remaining queries
                    }

                    // Update UI after each query completes
                    workstream.queryResults = queryResults;
                    container.innerHTML = renderWorkstreamContent(workstream, index);
                }

                // Final results are from the last query
                const finalTickets = queryResults.length > 0 ? queryResults[queryResults.length - 1].tickets : [];

                // Store results
                workstream.queryResults = queryResults;
                workstream.tickets = finalTickets;
                workstream.lastUpdated = new Date().toISOString();
                saveWorkstreams();

                // Final render to update header stats
                renderWorkstreams();

                // Clean up abort controller and restore buttons
                delete abortControllers[index];
                const refreshBtn = document.getElementById(`refresh-btn-${index}`);
                const cancelBtn = document.getElementById(`cancel-btn-${index}`);
                if (refreshBtn) refreshBtn.style.display = 'inline-block';
                if (cancelBtn) cancelBtn.style.display = 'none';
            } catch (error) {
                // Clean up abort controller and restore buttons
                delete abortControllers[index];
                const refreshBtn = document.getElementById(`refresh-btn-${index}`);
                const cancelBtn = document.getElementById(`cancel-btn-${index}`);
                if (refreshBtn) refreshBtn.style.display = 'inline-block';
                if (cancelBtn) cancelBtn.style.display = 'none';

                // Handle abort error differently
                if (error.name === 'AbortError') {
                    container.innerHTML = '<div class="error">Query execution cancelled</div>';
                } else {
                    container.innerHTML = `<div class="error">Error: ${escapeHtml(error.message)}</div>`;
                }
            }
        }

        function cancelWorkstreamRefresh(index) {
            if (abortControllers[index]) {
                abortControllers[index].abort();
                delete abortControllers[index];
            }
        }

        function handleTimeRangeChange(index) {
            const select = document.getElementById(`summary-days-${index}`);
            const customInput = document.getElementById(`custom-days-${index}`);

            if (select.value === 'custom') {
                customInput.style.display = 'inline-block';
                customInput.focus();
            } else {
                customInput.style.display = 'none';
            }
        }

        function getTimeRangeDays(index) {
            const select = document.getElementById(`summary-days-${index}`);
            if (select.value === 'custom') {
                const customInput = document.getElementById(`custom-days-${index}`);
                const customValue = parseInt(customInput.value);
                return customValue && customValue > 0 ? customValue : 7; // Default to 7 if invalid
            }
            return parseInt(select.value || 7);
        }

        function toggleContextInput(index) {
            const contextInput = document.getElementById(`context-input-${index}`);
            if (contextInput.style.display === 'none') {
                contextInput.style.display = 'flex';
            } else {
                contextInput.style.display = 'none';
            }
        }

        async function generateSummary(index) {
            const page = getCurrentPage();
            if (!page) return;

            const workstream = page.workstreams[index];

            if (!workstream.tickets || workstream.tickets.length === 0) {
                alert('No tickets loaded. Please refresh the workstream first.');
                return;
            }

            const days = getTimeRangeDays(index);

            const contextInput = document.getElementById(`summary-context-${index}`);
            const additionalContext = contextInput?.value.trim() || '';

            const omitInactiveCheckbox = document.getElementById(`omit-inactive-${index}`);
            const omitInactive = omitInactiveCheckbox?.checked || false;

            // Show loading state
            const originalButton = event.target;
            const originalText = originalButton.textContent;
            originalButton.textContent = 'â³ Generating...';
            originalButton.disabled = true;

            try {
                const ticketKeys = workstream.tickets.map(t => t.key);

                const response = await fetch(`${API_BASE}/workstream/summary`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        tickets: ticketKeys,
                        days: days,
                        context: additionalContext,
                        omit_inactive: omitInactive
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to generate summary');
                }

                const data = await response.json();

                // Store summary in workstream
                workstream.summary = {
                    text: data.summary,
                    generatedAt: new Date().toISOString(),
                    days: days,
                    changeCount: data.changeCount,
                    ticketCount: data.ticketCount
                };

                saveWorkstreams();
                renderWorkstreams();

            } catch (error) {
                console.error('Summary generation error:', error);
                alert(`Error generating summary: ${error.message}`);
            } finally {
                originalButton.textContent = originalText;
                originalButton.disabled = false;
            }
        }

        let currentMarkdownContent = '';
        let currentMarkdownFilename = '';

        async function exportWorkstreamMarkdown(index) {
            const page = getCurrentPage();
            if (!page) return;

            const workstream = page.workstreams[index];

            if (!workstream.tickets || workstream.tickets.length === 0) {
                alert('No tickets loaded. Please refresh the workstream first.');
                return;
            }

            const days = getTimeRangeDays(index);

            const omitInactiveCheckbox = document.getElementById(`omit-inactive-${index}`);
            const omitInactive = omitInactiveCheckbox?.checked || false;

            // Show loading state
            const originalButton = event.target;
            const originalText = originalButton.textContent;
            originalButton.textContent = 'â³ Exporting...';
            originalButton.disabled = true;

            // Show progress bar
            const progressContainer = document.getElementById(`export-progress-${index}`);
            const statusText = document.getElementById(`export-status-${index}`);
            const percentageText = document.getElementById(`export-percentage-${index}`);
            const progressBar = document.getElementById(`export-progress-bar-${index}`);

            progressContainer.style.display = 'block';
            statusText.textContent = 'Preparing export...';
            percentageText.textContent = '0%';
            progressBar.style.width = '0%';

            try {
                const ticketKeys = workstream.tickets.map(t => t.key);
                const totalTickets = ticketKeys.length;

                // Build markdown header
                let markdown = `# ${workstream.name}\n\n`;
                markdown += `**Export Date:** ${new Date().toLocaleString()}\n`;
                markdown += `**Time Range:** Last ${days} days\n`;
                markdown += `**Ticket Count:** ${totalTickets}\n\n`;

                // Add queries if provided
                if (workstream.queries && workstream.queries.length > 0) {
                    markdown += "## Queries\n\n";
                    workstream.queries.forEach((query, i) => {
                        const queryName = query.name || `Query ${i + 1}`;
                        markdown += `${i + 1}. **${queryName}**\n   \`\`\`jql\n   ${query.jql}\n   \`\`\`\n\n`;
                    });
                }

                markdown += "## Tickets\n\n";

                // Fetch tickets one by one with rate limiting
                const DELAY_MS = 300; // Delay between requests to avoid rate limiting

                for (let i = 0; i < ticketKeys.length; i++) {
                    const key = ticketKeys[i];
                    const progress = Math.round(((i + 1) / totalTickets) * 100);

                    // Update progress
                    statusText.textContent = `Fetching ${key}...`;
                    percentageText.textContent = `${progress}%`;
                    progressBar.style.width = `${progress}%`;

                    try {
                        // Fetch ticket details
                        const response = await fetch(`${API_BASE}/ticket/details`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                key: key,
                                days: days
                            })
                        });

                        if (response.ok) {
                            const ticket = await response.json();

                            // Update status with cache info
                            const cacheStatus = ticket._cache_hit ? 'âœ“ cached' : 'â†“ fetched';
                            statusText.textContent = `${key} (${cacheStatus})`;

                            // Calculate days since last activity
                            let daysSinceActivity = null;
                            let lastActivityDate = null;

                            // Check all changes and comments for the most recent date
                            const allActivities = [];

                            if (ticket.changes) {
                                ticket.changes.forEach(change => {
                                    if (change.date_iso) {
                                        allActivities.push(new Date(change.date_iso));
                                    }
                                });
                            }

                            if (ticket.comments) {
                                ticket.comments.forEach(comment => {
                                    if (comment.date_iso) {
                                        allActivities.push(new Date(comment.date_iso));
                                    }
                                });
                            }

                            if (allActivities.length > 0) {
                                lastActivityDate = new Date(Math.max(...allActivities));
                                const now = new Date();
                                const diffTime = Math.abs(now - lastActivityDate);
                                daysSinceActivity = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                            }

                            // Skip tickets with no activity if checkbox is checked
                            if (omitInactive && allActivities.length === 0) {
                                continue;
                            }

                            // Add ticket to markdown
                            markdown += `### ${ticket.key}: ${ticket.summary}\n\n`;
                            markdown += `- **Status:** ${ticket.status}\n`;
                            markdown += `- **Assignee:** ${ticket.assignee}\n`;
                            markdown += `- **Priority:** ${ticket.priority}\n`;

                            if (ticket.estimation) {
                                markdown += `- **Story Points:** ${ticket.estimation}\n`;
                            }

                            if (ticket.sprint) {
                                let sprintLabel = ticket.sprint;
                                if (ticket.sprint_state === 'active') {
                                    sprintLabel += ' (Active)';
                                } else if (ticket.sprint_state === 'future') {
                                    sprintLabel += ' (Planned)';
                                } else if (ticket.sprint_state === 'closed') {
                                    sprintLabel += ' (Closed)';
                                }
                                markdown += `- **Sprint:** ${sprintLabel}\n`;
                            }

                            if (daysSinceActivity !== null) {
                                markdown += `- **Days Since Last Activity:** ${daysSinceActivity}\n`;
                            }

                            markdown += `- **URL:** ${config.host}/browse/${ticket.key}\n\n`;

                            // Description
                            if (ticket.description) {
                                markdown += `**Description:**\n${ticket.description}\n\n`;
                            }

                            // Changelog
                            if (ticket.changes && ticket.changes.length > 0) {
                                markdown += `**Recent Changes (Last ${days} days):**\n`;
                                ticket.changes.forEach(change => {
                                    markdown += `- \`${change.date}\` **${change.author}**: ${change.field} changed from \`${change.from}\` to \`${change.to}\`\n`;
                                });
                                markdown += '\n';
                            }

                            // Comments
                            if (ticket.comments && ticket.comments.length > 0) {
                                markdown += `**Recent Comments (Last ${days} days):**\n`;
                                ticket.comments.forEach(comment => {
                                    markdown += `- \`${comment.date}\` **${comment.author}**:\n  ${comment.body.split('\n').join('\n  ')}\n\n`;
                                });
                            }

                            if (!ticket.changes || ticket.changes.length === 0) {
                                if (!ticket.comments || ticket.comments.length === 0) {
                                    markdown += `*No changes or comments in the last ${days} days*\n\n`;
                                }
                            }

                            markdown += "---\n\n";
                        } else {
                            // Error fetching this ticket
                            let errorMsg = `HTTP ${response.status}`;
                            try {
                                const errorData = await response.json();
                                if (errorData.error) {
                                    errorMsg = errorData.error;
                                }
                            } catch (e) {
                                // Unable to parse error response
                            }
                            console.error(`Error fetching ${key}: ${errorMsg}`);
                            markdown += `### ${key}\n*Error: ${errorMsg}*\n\n---\n\n`;
                        }

                    } catch (error) {
                        console.error(`Error fetching ${key}:`, error);
                        markdown += `### ${key}\n*Error: ${error.message}*\n\n---\n\n`;
                    }

                    // Rate limiting delay (except for last ticket)
                    if (i < ticketKeys.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, DELAY_MS));
                    }
                }

                // Store markdown content for copy/download
                currentMarkdownContent = markdown;
                currentMarkdownFilename = `${workstream.name.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${new Date().toISOString().split('T')[0]}.md`;

                // Hide progress bar
                progressContainer.style.display = 'none';

                // Show in modal
                document.getElementById('markdownContent').textContent = markdown;
                document.getElementById('markdownExportModal').style.display = 'flex';

            } catch (error) {
                console.error('Markdown export error:', error);
                alert(`Error exporting markdown: ${error.message}`);
                progressContainer.style.display = 'none';
            } finally {
                originalButton.textContent = originalText;
                originalButton.disabled = false;
            }
        }

        function closeMarkdownExportModal() {
            document.getElementById('markdownExportModal').style.display = 'none';
            currentMarkdownContent = '';
            currentMarkdownFilename = '';
        }

        function downloadMarkdown() {
            if (!currentMarkdownContent) return;

            const blob = new Blob([currentMarkdownContent], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = currentMarkdownFilename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function moveWorkstream(index, direction) {
            const page = getCurrentPage();
            if (!page) return;

            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= page.workstreams.length) {
                return;
            }

            // Swap workstreams
            const temp = page.workstreams[index];
            page.workstreams[index] = page.workstreams[newIndex];
            page.workstreams[newIndex] = temp;

            saveWorkstreams();
            renderWorkstreams();
        }

        async function fetchTickets(query, forceJQL = false, signal = null) {
            // If forceJQL is true (e.g., from FOREACH or explicit JQL type), skip auto-detection
            // Otherwise, use heuristic to detect if it's a simple ticket key list
            let isTicketKeys = false;

            if (!forceJQL) {
                // Check if query contains common JQL keywords or special chars
                const jqlKeywords = ['in', 'AND', 'OR', 'NOT', '=', '!=', '~', '>', '<', 'is', 'was', 'order by', 'ORDER BY'];
                const hasJqlKeyword = jqlKeywords.some(keyword => query.toLowerCase().includes(keyword.toLowerCase()));
                const hasParentheses = query.includes('(') || query.includes(')');

                // Only treat as ticket keys if it looks like a simple comma-separated list
                isTicketKeys = !hasJqlKeyword && !hasParentheses && query.trim().match(/^[A-Z0-9\-,\s]+$/);
            }

            console.log(`    fetchTickets() - forceJQL: ${forceJQL}, isTicketKeys: ${isTicketKeys}, query: ${query}`);

            if (isTicketKeys) {
                const keys = query.split(',').map(k => k.trim()).filter(k => k);
                const tickets = [];

                for (const key of keys) {
                    try {
                        const fetchOptions = signal ? { signal } : {};
                        const response = await fetch(`${API_BASE}/issue/${key}`, fetchOptions);
                        if (response.ok) {
                            const ticket = await response.json();
                            tickets.push(ticket);
                        }
                    } catch (error) {
                        console.error(`Failed to fetch ${key}:`, error);
                        // Re-throw abort errors
                        if (error.name === 'AbortError') throw error;
                    }
                }

                return tickets;
            } else {
                const fetchOptions = {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ jql: query })
                };
                if (signal) fetchOptions.signal = signal;

                const response = await fetch(`${API_BASE}/search`, fetchOptions);

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to fetch tickets');
                }

                const data = await response.json();
                return data.tickets;
            }
        }

        function toggleGroupBy(index, groupType) {
            const page = getCurrentPage();
            if (!page) return;

            const ws = page.workstreams[index];

            // If clicking the same type, toggle it off
            if (ws.groupBy === groupType) {
                ws.groupBy = null;
            } else {
                ws.groupBy = groupType;
            }

            saveWorkstreams();
            renderWorkstreams();

            const container = document.getElementById(`workstream-content-${index}`);
            if (ws.queryResults && ws.queryResults.length > 0) {
                container.innerHTML = renderWorkstreamContent(ws, index);
            }
        }

        function setView(index, viewType) {
            const page = getCurrentPage();
            if (!page) return;

            const ws = page.workstreams[index];
            ws.view = viewType;

            saveWorkstreams();
            renderWorkstreams();

            const container = document.getElementById(`workstream-content-${index}`);
            if (ws.queryResults && ws.queryResults.length > 0) {
                container.innerHTML = renderWorkstreamContent(ws, index);
            }
        }

        function renderWorkstreamContent(workstream, index) {
            const queries = workstream.queries || [];
            const queryResults = workstream.queryResults || [];

            // If no queries defined at all
            if (queries.length === 0) {
                return '<div class="empty-state">Click Refresh to load tickets</div>';
            }

            let html = '';

            // Render each query's results
            queries.forEach((query, i) => {
                const result = queryResults[i];
                const queryLabel = query.name || `Query ${i + 1}`;
                const queryTypeDisplay = getQueryTypeLabel(query);
                const typeLabel = queryTypeDisplay !== 'JQL' ? ` <span class="query-type-badge">${queryTypeDisplay}</span>` : '';

                // Determine loading/error/success state
                let statusContent = '';
                let resultContent = '';

                if (!result) {
                    // Query hasn't been executed yet - show as pending
                    statusContent = '<span class="query-status-badge query-pending">Pending</span>';
                    resultContent = '<div class="empty-state">Waiting to execute...</div>';
                } else if (result.loading) {
                    // Query is currently executing
                    statusContent = '<span class="query-status-badge query-loading">Loading...</span>';
                    resultContent = '<div class="loading"><span class="loading-with-spinner"><div class="spinner"></div>Executing query...</span></div>';
                } else if (result.error) {
                    // Query had an error
                    statusContent = `<span class="query-error-badge">Error: ${escapeHtml(result.error)}</span>`;
                    resultContent = `<div class="error">${escapeHtml(result.error)}</div>`;
                } else if (result.skipped) {
                    // Query was skipped
                    statusContent = '<span class="query-skipped-badge">Skipped</span>';
                    resultContent = '<div class="empty-state">Skipped</div>';
                } else {
                    // Query completed successfully
                    statusContent = `<span class="query-result-count">${result.count} tickets</span>`;

                    if (result.tickets && result.tickets.length > 0) {
                        // For the last query, show full ticket cards; for others, show keys list
                        const isLastQuery = i === queries.length - 1;
                        if (isLastQuery) {
                            resultContent = renderTicketsHTML(result.tickets, workstream.groupBy, workstream.view);
                        } else {
                            // Show ticket keys list for intermediate queries
                            resultContent = `<div class="ticket-keys-list">${result.tickets.map(t =>
                                `<a href="${config.host}/browse/${t.key}" target="_blank" class="ticket-key-link">${escapeHtml(t.key)}</a>`
                            ).join(', ')}</div>`;
                        }
                    } else {
                        resultContent = '<div class="empty-state">No tickets found</div>';
                    }
                }

                html += `
                    <div id="query-result-item-${index}-${i}" class="query-result-item ${result?.error ? 'has-error' : ''} ${result?.loading ? 'loading' : ''}">
                        <div class="query-result-header-simple">
                            <span class="query-result-title">
                                ${escapeHtml(queryLabel)}${typeLabel}
                            </span>
                            ${statusContent}
                        </div>
                        <div class="query-result-content-simple">
                            ${resultContent}
                        </div>
                    </div>
                `;
            });

            return html;
        }

        function renderTicketsHTML(tickets, groupBy = null, view = 'cards') {
            if (tickets.length === 0) {
                return '<div class="empty-state">No tickets found</div>';
            }

            if (view === 'tree') {
                return renderTreeView(tickets);
            } else if (groupBy === 'epic') {
                return renderTicketsByEpic(tickets, view);
            } else if (groupBy === 'parent') {
                return renderTicketsByParent(tickets, view);
            } else if (groupBy === 'assignee') {
                return renderTicketsByAssignee(tickets, view);
            } else {
                return renderTicketsByStatus(tickets, view);
            }
        }

        function renderTicketsByEpic(tickets, view = 'cards') {
            // Group tickets by epic
            const epicGroups = {};
            const noEpic = [];

            tickets.forEach(ticket => {
                if (ticket.epicKey) {
                    if (!epicGroups[ticket.epicKey]) {
                        epicGroups[ticket.epicKey] = {
                            name: ticket.epicName || ticket.epicKey,
                            tickets: []
                        };
                    }
                    epicGroups[ticket.epicKey].tickets.push(ticket);
                } else {
                    noEpic.push(ticket);
                }
            });

            let html = '';

            // Render each epic as a sub-swimlane
            Object.entries(epicGroups).forEach(([epicKey, epic]) => {
                html += `
                    <div class="sub-swimlane">
                        <div class="sub-swimlane-header">
                            <a href="${config.host}/browse/${epicKey}" target="_blank" style="color: inherit; text-decoration: none;">
                                ðŸš€ ${escapeHtml(epicKey)}: ${escapeHtml(epic.name)}
                            </a>
                            <span style="color: var(--text-secondary); margin-left: 8px;">(${epic.tickets.length})</span>
                        </div>
                        <div class="sub-swimlane-body">
                            ${renderTicketsByStatus(epic.tickets, view)}
                        </div>
                    </div>
                `;
            });

            // Render tickets without epic
            if (noEpic.length > 0) {
                html += `
                    <div class="sub-swimlane">
                        <div class="sub-swimlane-header">
                            ðŸ“‹ No Epic (${noEpic.length})
                        </div>
                        <div class="sub-swimlane-body">
                            ${renderTicketsByStatus(noEpic, view)}
                        </div>
                    </div>
                `;
            }

            return html;
        }

        function renderTicketsByParent(tickets, view = 'cards') {
            // Group tickets by parent
            const parentGroups = {};
            const noParent = [];

            tickets.forEach(ticket => {
                if (ticket.parentKey) {
                    if (!parentGroups[ticket.parentKey]) {
                        parentGroups[ticket.parentKey] = {
                            name: ticket.parentName || ticket.parentKey,
                            tickets: []
                        };
                    }
                    parentGroups[ticket.parentKey].tickets.push(ticket);
                } else {
                    noParent.push(ticket);
                }
            });

            let html = '';

            // Render each parent as a sub-swimlane
            Object.entries(parentGroups).forEach(([parentKey, parent]) => {
                html += `
                    <div class="sub-swimlane">
                        <div class="sub-swimlane-header">
                            <a href="${config.host}/browse/${parentKey}" target="_blank" style="color: inherit; text-decoration: none;">
                                ðŸ“Ž ${escapeHtml(parentKey)}: ${escapeHtml(parent.name)}
                            </a>
                            <span style="color: var(--text-secondary); margin-left: 8px;">(${parent.tickets.length})</span>
                        </div>
                        <div class="sub-swimlane-body">
                            ${renderTicketsByStatus(parent.tickets, view)}
                        </div>
                    </div>
                `;
            });

            // Render tickets without parent
            if (noParent.length > 0) {
                html += `
                    <div class="sub-swimlane">
                        <div class="sub-swimlane-header">
                            ðŸ“‹ No Parent (${noParent.length})
                        </div>
                        <div class="sub-swimlane-body">
                            ${renderTicketsByStatus(noParent, view)}
                        </div>
                    </div>
                `;
            }

            return html;
        }

        function renderTicketsByAssignee(tickets, view = 'cards') {
            // Group tickets by assignee
            const assigneeGroups = {};

            tickets.forEach(ticket => {
                const assignee = ticket.assignee || 'Unassigned';
                if (!assigneeGroups[assignee]) {
                    assigneeGroups[assignee] = [];
                }
                assigneeGroups[assignee].push(ticket);
            });

            let html = '';

            // Sort assignees alphabetically, but put Unassigned last
            const sortedAssignees = Object.keys(assigneeGroups).sort((a, b) => {
                if (a === 'Unassigned') return 1;
                if (b === 'Unassigned') return -1;
                return a.localeCompare(b);
            });

            // Render each assignee as a sub-swimlane
            sortedAssignees.forEach(assignee => {
                const tickets = assigneeGroups[assignee];
                html += `
                    <div class="sub-swimlane">
                        <div class="sub-swimlane-header">
                            ðŸ‘¤ ${escapeHtml(assignee)}
                            <span style="color: var(--text-secondary); margin-left: 8px;">(${tickets.length})</span>
                        </div>
                        <div class="sub-swimlane-body">
                            ${renderTicketsByStatus(tickets, view)}
                        </div>
                    </div>
                `;
            });

            return html;
        }

        function renderTicketsByStatus(tickets, view = 'cards') {
            // Group tickets by status category
            const columns = {
                'new': { title: 'New', tickets: [] },
                'indeterminate': { title: 'In Progress', tickets: [] },
                'review': { title: 'Review', tickets: [] },
                'done': { title: 'Done', tickets: [] }
            };

            // Categorize tickets
            tickets.forEach(ticket => {
                const category = ticket.statusCategory || 'other';
                // Map status names that contain "review" to review column
                if (ticket.status && ticket.status.toLowerCase().includes('review')) {
                    ticket.displayCategory = 'review';
                    columns['review'].tickets.push(ticket);
                } else if (columns[category]) {
                    ticket.displayCategory = category;
                    columns[category].tickets.push(ticket);
                } else {
                    // Default to in progress for unknown statuses
                    ticket.displayCategory = 'indeterminate';
                    columns['indeterminate'].tickets.push(ticket);
                }
            });

            if (view === 'compact') {
                return renderCompactView(columns);
            } else {
                return renderCardsView(columns);
            }
        }

        function renderCardsView(columns) {
            return `
                <div class="kanban-board">
                    ${Object.entries(columns).map(([key, column]) => `
                        <div class="kanban-column">
                            <div class="kanban-column-header">
                                <span class="kanban-column-title">${column.title}</span>
                                <span class="kanban-column-count">${column.tickets.length}</span>
                            </div>
                            <div class="kanban-tickets">
                                ${column.tickets.length === 0
                                    ? '<div style="text-align: center; padding: 20px; color: var(--text-secondary); font-size: 12px;">No tickets</div>'
                                    : column.tickets.map(ticket => `
                                        <div class="ticket-card">
                                            <a href="${config.host}/browse/${ticket.key}" target="_blank" class="ticket-key">
                                                ${escapeHtml(ticket.key)}
                                            </a>
                                            <div class="ticket-summary">${escapeHtml(ticket.summary)}</div>
                                            <div class="ticket-meta">
                                                <span class="ticket-status status-${ticket.displayCategory || ticket.statusCategory}">
                                                    ${escapeHtml(ticket.status)}
                                                </span>
                                                <span class="ticket-assignee">ðŸ‘¤ ${escapeHtml(ticket.assignee)}</span>
                                                ${ticket.storyPoints ? `<span class="ticket-story-points">${ticket.storyPoints} SP</span>` : ''}
                                                ${ticket.statusCategory === 'done' && ticket.resolution ? `<span class="ticket-resolution">${escapeHtml(ticket.resolution)}</span>` : ''}
                                                ${(ticket.displayCategory === 'indeterminate' || ticket.displayCategory === 'review') && ticket.statusChangeDate ? `<span class="ticket-since">${formatSince(ticket.statusChangeDate)}</span>` : ''}
                                            </div>
                                        </div>
                                    `).join('')
                                }
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function ensureDisplayCategory(ticket) {
            if (!ticket.displayCategory && ticket.status) {
                const category = ticket.statusCategory || 'other';
                if (ticket.status.toLowerCase().includes('review')) {
                    ticket.displayCategory = 'review';
                } else {
                    ticket.displayCategory = category;
                }
            }
        }

        function renderTreeView(tickets) {
            if (tickets.length === 0) {
                return '<div class="tree-empty">No tickets to display</div>';
            }

            // Build a map of all tickets by key
            const ticketMap = {};
            const queryTickets = new Set(); // Track tickets from the original query
            tickets.forEach(ticket => {
                ensureDisplayCategory(ticket);
                ticketMap[ticket.key] = ticket;
                queryTickets.add(ticket.key);
            });

            // Build virtual epic/parent nodes if they don't exist in the ticket list
            const virtualNodes = createVirtualNodes(tickets, ticketMap);

            // Merge virtual nodes with ticket map
            Object.assign(ticketMap, virtualNodes);

            // Build hierarchy (this already filters out tickets that appear as children)
            const hierarchyResult = buildTreeHierarchy(tickets, ticketMap, virtualNodes);

            return `
                <div class="tree-view">
                    ${renderTreeNodes(hierarchyResult.roots, ticketMap, 0, hierarchyResult.claimedByLinks, queryTickets)}
                </div>
            `;
        }

        function renderTreeNodes(nodes, ticketMap, level, claimedByLinks, queryTickets) {
            return nodes.map(ticket => renderTreeNode(ticket, ticketMap, level, claimedByLinks, queryTickets)).join('');
        }

        function renderTreeNode(ticket, ticketMap, level, claimedByLinks, queryTickets) {
            const hasChildren = hasTicketChildren(ticket, ticketMap);
            const toggleId = `toggle-${ticket.key.replace(/[^a-zA-Z0-9]/g, '_')}-${level}`;
            // Grey out tickets (including virtual nodes) that aren't in the query
            const notInQuery = !queryTickets.has(ticket.key);

            // Ensure ticket has displayCategory set (in case it's a virtual node or wasn't processed earlier)
            ensureDisplayCategory(ticket);

            // Determine status display
            const statusHtml = ticket.isVirtual
                ? ''
                : `<span class="tree-status status-${ticket.displayCategory || ticket.statusCategory}">
                    ${escapeHtml(ticket.status)}
                </span>`;

            let html = `
                <div class="tree-node" style="margin-left: ${level * 20}px;">
                    <div class="tree-node-content${notInQuery ? ' tree-node-not-in-query' : ''}">
                        ${hasChildren
                            ? `<span class="tree-toggle" onclick="toggleTreeNode('${toggleId}')">â–¼</span>`
                            : '<span class="tree-toggle">â€¢</span>'}
                        <span class="tree-icon">${getTicketIcon(ticket)}</span>
                        <a href="${config.host}/browse/${ticket.key}" target="_blank" class="tree-key">
                            ${escapeHtml(ticket.key)}
                        </a>
                        <span class="tree-summary">${escapeHtml(ticket.summary)}</span>
                        ${statusHtml}
                        <span class="tree-meta">
                            ${escapeHtml(ticket.assignee)}
                            ${ticket.storyPoints ? ` â€¢ ${ticket.storyPoints} SP` : ''}
                            ${ticket.statusCategory === 'done' && ticket.resolution ? ` â€¢ ${escapeHtml(ticket.resolution)}` : ''}
                            ${(ticket.displayCategory === 'indeterminate' || ticket.displayCategory === 'review') && ticket.statusChangeDate ? ` â€¢ ${formatSince(ticket.statusChangeDate)}` : ''}
                        </span>
                    </div>
                    ${hasChildren ? `<div id="${toggleId}" class="tree-children">${renderTicketChildren(ticket, ticketMap, level, claimedByLinks, queryTickets)}</div>` : ''}
                </div>
            `;

            return html;
        }

        function createVirtualNodes(tickets, ticketMap) {
            const virtualNodes = {};

            tickets.forEach(ticket => {
                // Create virtual epic node if epic doesn't exist in tickets
                if (ticket.epicKey && !ticketMap[ticket.epicKey]) {
                    virtualNodes[ticket.epicKey] = {
                        key: ticket.epicKey,
                        summary: ticket.epicName || ticket.epicKey,
                        status: 'Unknown',
                        statusCategory: 'other',
                        assignee: '-',
                        type: 'Epic',
                        isVirtual: true
                    };
                }

                // Create virtual parent node if parent doesn't exist in tickets
                if (ticket.parentKey && !ticketMap[ticket.parentKey] && !virtualNodes[ticket.parentKey]) {
                    virtualNodes[ticket.parentKey] = {
                        key: ticket.parentKey,
                        summary: ticket.parentName || ticket.parentKey,
                        status: 'Unknown',
                        statusCategory: 'other',
                        assignee: '-',
                        type: 'Story',
                        isVirtual: true
                    };
                }
            });

            return virtualNodes;
        }

        function buildTreeHierarchy(tickets, ticketMap, virtualNodes) {
            const roots = [];
            const processed = new Set();
            const claimed = new Set(); // Track tickets that are children of others
            const claimedByLinks = new Set(); // Track tickets claimed by issue links specifically

            // First pass: identify all tickets that are claimed as children
            tickets.forEach(ticket => {
                // If this ticket has an epic in the dataset, it's claimed by that epic
                if (ticket.epicKey && (ticketMap[ticket.epicKey] || virtualNodes[ticket.epicKey])) {
                    claimed.add(ticket.key);
                }
                // If this ticket has a parent in the dataset, it's claimed by that parent
                else if (ticket.parentKey && (ticketMap[ticket.parentKey] || virtualNodes[ticket.parentKey])) {
                    claimed.add(ticket.key);
                }
            });

            // Second pass: mark tickets that appear as children of any other ticket
            tickets.forEach(ticket => {
                // Mark tickets referenced in subtasks as claimed
                if (ticket.subtasks) {
                    ticket.subtasks.forEach(st => claimed.add(st.key));
                }

                // Mark tickets referenced in issue links as claimed
                // Only claim for outward relationships (depends on, blocks, etc), not inward (is depended on by)
                if (ticket.issueLinks && ticket.issueLinks.length > 0) {
                    ticket.issueLinks.forEach(link => {
                        // Only claim tickets for relationship types that represent outward dependencies
                        // (where the current ticket depends on or blocks the linked ticket)
                        const linkType = (link.type || '').toLowerCase();
                        const isOutward = (linkType.includes('depend') && !linkType.includes('is depended')) ||
                                        (linkType.includes('block') && !linkType.includes('is blocked')) ||
                                        linkType.includes('relates');

                        if (isOutward && link.key && ticketMap[link.key]) {
                            claimed.add(link.key);
                            claimedByLinks.add(link.key); // Track separately for rendering
                        }
                    });
                }
            });

            // Add virtual nodes as roots (they're never claimed)
            Object.keys(virtualNodes).forEach(key => {
                roots.push(virtualNodes[key]);
                processed.add(key);
            });

            // Third pass: add only unclaimed tickets as roots
            tickets.forEach(ticket => {
                if (processed.has(ticket.key) || claimed.has(ticket.key)) {
                    return;
                }

                roots.push(ticket);
                processed.add(ticket.key);
            });

            // Sort roots by status
            sortTicketsByStatus(roots);

            return { roots, claimedByLinks };
        }


        function hasTicketChildren(ticket, ticketMap) {
            // Check if this ticket has subtasks
            if (ticket.subtasks && ticket.subtasks.length > 0) return true;

            // Check if any tickets have this as epic (for epic nodes)
            if (ticket.type === 'Epic' || ticket.isVirtual) {
                for (const key in ticketMap) {
                    const other = ticketMap[key];
                    if (!other.isVirtual && other.epicKey === ticket.key) {
                        return true;
                    }
                }
            }

            // Check if any tickets have this as parent
            for (const key in ticketMap) {
                const other = ticketMap[key];
                if (!other.isVirtual && other.parentKey === ticket.key) {
                    return true;
                }
            }

            // Check for relevant issue links (but not for virtual nodes)
            if (!ticket.isVirtual && ticket.issueLinks && ticket.issueLinks.length > 0) {
                const relevantLinks = ticket.issueLinks.filter(link =>
                    link.type && (
                        link.type.toLowerCase().includes('block') ||
                        link.type.toLowerCase().includes('depend') ||
                        link.type.toLowerCase().includes('relates')
                    )
                );
                if (relevantLinks.length > 0) return true;
            }

            return false;
        }

        function getStatusSortOrder(ticket) {
            const category = ticket.displayCategory || ticket.statusCategory || 'other';
            const sortOrder = {
                'new': 0,
                'indeterminate': 1,
                'review': 2,
                'done': 3,
                'other': 4
            };
            return sortOrder[category] !== undefined ? sortOrder[category] : 4;
        }

        function sortTicketsByStatus(tickets) {
            return tickets.sort((a, b) => {
                const orderA = getStatusSortOrder(a);
                const orderB = getStatusSortOrder(b);
                return orderA - orderB;
            });
        }

        function renderTicketChildren(ticket, ticketMap, level, claimedByLinks, queryTickets) {
            let html = '';
            const allChildren = [];

            // Collect children via epic link
            if (ticket.type === 'Epic' || ticket.isVirtual) {
                for (const key in ticketMap) {
                    const other = ticketMap[key];
                    if (!other.isVirtual && other.epicKey === ticket.key && other.key !== ticket.key && !claimedByLinks.has(other.key)) {
                        allChildren.push(other);
                    }
                }
            }

            // Collect children via parent link (for all tickets, including virtual nodes)
            for (const key in ticketMap) {
                const other = ticketMap[key];
                if (!other.isVirtual && other.parentKey === ticket.key && other.key !== ticket.key && !claimedByLinks.has(other.key)) {
                    // Avoid duplicates if a ticket is already added via epicKey
                    if (!allChildren.find(t => t.key === other.key)) {
                        allChildren.push(other);
                    }
                }
            }

            // Render collected children
            if (allChildren.length > 0) {
                sortTicketsByStatus(allChildren);
                html += renderTreeNodes(allChildren, ticketMap, level + 1, claimedByLinks, queryTickets);
            }

            // Show subtasks (only for real tickets, not virtual nodes)
            if (!ticket.isVirtual && ticket.subtasks && ticket.subtasks.length > 0) {
                ticket.subtasks.forEach(subtask => {
                    // Check if we have full ticket data for this subtask
                    const fullSubtask = ticketMap[subtask.key];
                    const notInQuery = !queryTickets.has(subtask.key);
                    let statusHtml, metaHtml;

                    if (fullSubtask && !fullSubtask.isVirtual) {
                        // We have full ticket data
                        statusHtml = `<span class="tree-status status-${fullSubtask.displayCategory || fullSubtask.statusCategory}">${escapeHtml(fullSubtask.status)}</span>`;
                        metaHtml = `<span class="tree-meta">
                            ${escapeHtml(fullSubtask.assignee)}
                            ${fullSubtask.storyPoints ? ` â€¢ ${fullSubtask.storyPoints} SP` : ''}
                            ${fullSubtask.statusCategory === 'done' && fullSubtask.resolution ? ` â€¢ ${escapeHtml(fullSubtask.resolution)}` : ''}
                            ${(fullSubtask.displayCategory === 'indeterminate' || fullSubtask.displayCategory === 'review') && fullSubtask.statusChangeDate ? ` â€¢ ${formatSince(fullSubtask.statusChangeDate)}` : ''}
                        </span>`;
                    } else {
                        // Limited data from subtask object
                        statusHtml = `<span class="tree-meta">${escapeHtml(subtask.status)}</span>`;
                        metaHtml = '';
                    }

                    html += `
                        <div class="tree-node" style="margin-left: ${(level + 1) * 20}px;">
                            <div class="tree-node-content${notInQuery ? ' tree-node-not-in-query' : ''}">
                                <span class="tree-toggle">â€¢</span>
                                <span class="tree-icon">ðŸ“‹</span>
                                <a href="${config.host}/browse/${subtask.key}" target="_blank" class="tree-key">
                                    ${escapeHtml(subtask.key)}
                                </a>
                                <span class="tree-summary">${escapeHtml(subtask.summary)}</span>
                                ${statusHtml}
                                ${metaHtml}
                            </div>
                        </div>
                    `;
                });
            }

            // Show issue links (blocks, depends on, etc.) - only for real tickets
            if (!ticket.isVirtual && ticket.issueLinks && ticket.issueLinks.length > 0) {
                const relevantLinks = ticket.issueLinks.filter(link => {
                    if (!link.type) return false;
                    const linkType = link.type.toLowerCase();
                    // Show all relationship types (blocks, depends on, relates to, and their inverses)
                    return linkType.includes('depend') ||
                           linkType.includes('block') ||
                           linkType.includes('relates');
                });

                if (relevantLinks.length > 0) {
                    relevantLinks.forEach(link => {
                        // Check if we have full ticket data for this linked issue
                        const fullLinkedTicket = ticketMap[link.key];
                        const notInQuery = !queryTickets.has(link.key);
                        let statusHtml = '', metaHtml = '';

                        if (fullLinkedTicket && !fullLinkedTicket.isVirtual) {
                            // We have full ticket data
                            statusHtml = `<span class="tree-status status-${fullLinkedTicket.displayCategory || fullLinkedTicket.statusCategory}">${escapeHtml(fullLinkedTicket.status)}</span>`;
                            metaHtml = `<span class="tree-meta">
                                ${escapeHtml(fullLinkedTicket.assignee)}
                                ${fullLinkedTicket.storyPoints ? ` â€¢ ${fullLinkedTicket.storyPoints} SP` : ''}
                                ${fullLinkedTicket.statusCategory === 'done' && fullLinkedTicket.resolution ? ` â€¢ ${escapeHtml(fullLinkedTicket.resolution)}` : ''}
                                ${(fullLinkedTicket.displayCategory === 'indeterminate' || fullLinkedTicket.displayCategory === 'review') && fullLinkedTicket.statusChangeDate ? ` â€¢ ${formatSince(fullLinkedTicket.statusChangeDate)}` : ''}
                            </span>`;
                        }

                        html += `
                            <div class="tree-link-label" style="margin-left: ${(level + 1) * 20}px;">
                                ${escapeHtml(link.type)}
                            </div>
                            <div class="tree-node" style="margin-left: ${(level + 1) * 20}px;">
                                <div class="tree-node-content${notInQuery ? ' tree-node-not-in-query' : ''}">
                                    <span class="tree-toggle">â€¢</span>
                                    <span class="tree-icon">ðŸ”—</span>
                                    <a href="${config.host}/browse/${link.key}" target="_blank" class="tree-key">
                                        ${escapeHtml(link.key)}
                                    </a>
                                    <span class="tree-summary">${escapeHtml(link.summary)}</span>
                                    ${statusHtml}
                                    ${metaHtml}
                                </div>
                            </div>
                        `;
                    });
                }
            }

            return html;
        }

        function getTicketIcon(ticket) {
            if (ticket.type === 'Epic') return 'ðŸš€';
            if (ticket.type === 'Story') return 'ðŸ“–';
            if (ticket.type === 'Bug') return 'ðŸ›';
            if (ticket.type === 'Task') return 'âœ“';
            return 'ðŸ“„';
        }

        function toggleTreeNode(nodeId) {
            const node = document.getElementById(nodeId);
            if (node) {
                const toggle = node.previousElementSibling?.querySelector('.tree-toggle');
                if (node.style.display === 'none') {
                    node.style.display = 'block';
                    if (toggle) toggle.textContent = 'â–¼';
                } else {
                    node.style.display = 'none';
                    if (toggle) toggle.textContent = 'â–¶';
                }
            }
        }

        function expandAllTreeNodes() {
            const treeChildren = document.querySelectorAll('.tree-children');
            treeChildren.forEach(node => {
                node.style.display = 'block';
            });
            const toggles = document.querySelectorAll('.tree-toggle');
            toggles.forEach(toggle => {
                if (toggle.textContent === 'â–¶') {
                    toggle.textContent = 'â–¼';
                }
            });
        }

        function collapseAllTreeNodes() {
            const treeChildren = document.querySelectorAll('.tree-children');
            treeChildren.forEach(node => {
                node.style.display = 'none';
            });
            const toggles = document.querySelectorAll('.tree-toggle');
            toggles.forEach(toggle => {
                if (toggle.textContent === 'â–¼') {
                    toggle.textContent = 'â–¶';
                }
            });
        }

        function renderCompactView(columns) {
            // Collect all tickets across all columns
            const allTickets = [];
            Object.entries(columns).forEach(([key, column]) => {
                column.tickets.forEach(ticket => {
                    allTickets.push(ticket);
                });
            });

            if (allTickets.length === 0) {
                return '<div class="table-empty">No tickets to display</div>';
            }

            // Sort by status category, then by key
            const statusOrder = { 'new': 0, 'indeterminate': 1, 'review': 2, 'done': 3 };
            allTickets.sort((a, b) => {
                const statusA = statusOrder[a.displayCategory || a.statusCategory] || 999;
                const statusB = statusOrder[b.displayCategory || b.statusCategory] || 999;
                if (statusA !== statusB) return statusA - statusB;
                return (a.key || '').localeCompare(b.key || '');
            });

            return `
                <div class="table-view-container">
                    <table class="table-view">
                        <thead>
                            <tr>
                                <th class="key-column">Key</th>
                                <th>Summary</th>
                                <th class="status-column">Status</th>
                                <th class="assignee-column">Assignee</th>
                                <th class="points-column">SP</th>
                                <th class="duration-column">Since</th>
                                <th class="resolution-column">Resolution</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${allTickets.map(ticket => `
                                <tr>
                                    <td>
                                        <a href="${config.host}/browse/${ticket.key}" target="_blank" class="table-key">
                                            ${escapeHtml(ticket.key)}
                                        </a>
                                    </td>
                                    <td class="table-summary">${escapeHtml(ticket.summary)}</td>
                                    <td>
                                        <span class="table-status status-${ticket.displayCategory || ticket.statusCategory}">
                                            ${escapeHtml(ticket.status)}
                                        </span>
                                    </td>
                                    <td class="table-assignee">${escapeHtml(ticket.assignee)}</td>
                                    <td class="table-points">${ticket.storyPoints || '-'}</td>
                                    <td class="table-since">${(ticket.displayCategory === 'indeterminate' || ticket.displayCategory === 'review') && ticket.statusChangeDate ? formatSince(ticket.statusChangeDate) : '-'}</td>
                                    <td class="table-resolution">${ticket.statusCategory === 'done' && ticket.resolution ? escapeHtml(ticket.resolution) : '-'}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        async function refreshAll() {
            const page = getCurrentPage();
            if (!page) return;

            for (let index = 0; index < page.workstreams.length; index++) {
                await refreshWorkstream(index);
                // Add 1 second delay between refreshes to avoid rate limiting
                if (index < page.workstreams.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
        }

        function clearAll() {
            const page = getCurrentPage();
            if (!page) return;

            if (confirm(`This will delete all workstreams in page "${page.name}". Continue?`)) {
                page.workstreams = [];
                saveWorkstreams();
                renderWorkstreams();
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatTimestamp(isoString) {
            const date = new Date(isoString);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            // Relative time for recent updates
            if (diffMins < 1) {
                return 'just now';
            } else if (diffMins < 60) {
                return `${diffMins} minute${diffMins !== 1 ? 's' : ''} ago`;
            } else if (diffHours < 24) {
                return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
            } else if (diffDays < 7) {
                return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
            } else {
                // Absolute time for older updates
                return date.toLocaleString();
            }
        }

        function formatSince(isoString) {
            if (!isoString) return null;
            const date = new Date(isoString);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            let duration;
            if (diffMins < 60) {
                duration = `${diffMins}m`;
            } else if (diffHours < 24) {
                duration = `${diffHours}h`;
            } else if (diffDays < 30) {
                duration = `${diffDays}d`;
            } else {
                const diffMonths = Math.floor(diffDays / 30);
                duration = `${diffMonths}mo`;
            }
            return `Since ${duration}`;
        }

        function exportConfiguration() {
            // Create a clean config export (without ticket data)
            const configExport = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                pages: data.pages.map(page => ({
                    id: page.id,
                    name: page.name,
                    workstreams: page.workstreams.map(ws => ({
                        id: ws.id,
                        name: ws.name,
                        jql: ws.jql, // Keep for backward compatibility
                        queries: ws.queries, // New query stack format
                        groupBy: ws.groupBy,
                        view: ws.view
                    }))
                })),
                currentPageId: data.currentPageId
            };

            // Create filename with timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const filename = `jira-workstreams-config-${timestamp}.json`;

            // Download as file
            const blob = new Blob([JSON.stringify(configExport, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            alert(`Configuration exported to ${filename}`);
        }

        async function importConfiguration(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const importedConfig = JSON.parse(e.target.result);

                    // Validate structure
                    if (!importedConfig.pages || !Array.isArray(importedConfig.pages)) {
                        alert('Invalid configuration file: missing pages array');
                        return;
                    }

                    // Ask user how to import
                    const choice = confirm(
                        'How do you want to import this configuration?\n\n' +
                        'OK = Replace all existing pages and workstreams\n' +
                        'Cancel = Merge with existing (add new pages)'
                    );

                    if (choice) {
                        // Replace mode
                        data.pages = importedConfig.pages.map(page => ({
                            ...page,
                            workstreams: page.workstreams.map(ws => ({
                                ...ws,
                                tickets: undefined // Clear ticket data - undefined means not refreshed
                            }))
                        }));
                        data.currentPageId = importedConfig.currentPageId || data.pages[0]?.id;
                    } else {
                        // Merge mode - add imported pages with new IDs to avoid conflicts
                        const newPages = importedConfig.pages.map(page => ({
                            id: Date.now() + Math.random(), // New ID to avoid conflicts
                            name: page.name + ' (imported)',
                            workstreams: page.workstreams.map(ws => ({
                                id: Date.now() + Math.random(),
                                name: ws.name,
                                jql: ws.jql,
                                queries: ws.queries, // Include queries for new format
                                groupBy: ws.groupBy,
                                view: ws.view,
                                tickets: undefined, // undefined means not refreshed
                                queryResults: undefined
                            }))
                        }));
                        data.pages.push(...newPages);
                    }

                    // Ensure currentPageId is valid
                    if (!data.pages.find(p => p.id === data.currentPageId)) {
                        data.currentPageId = data.pages[0].id;
                    }

                    // Migrate all imported workstreams to new format
                    data.pages.forEach(page => {
                        if (page.workstreams) {
                            page.workstreams = page.workstreams.map(ws => migrateWorkstream(ws));
                        }
                    });

                    await saveWorkstreams();
                    renderTabs();
                    renderWorkstreams();

                    alert('Configuration imported successfully!');
                } catch (error) {
                    alert('Error importing configuration: ' + error.message);
                    console.error('Import error:', error);
                }
            };
            reader.readAsText(file);

            // Reset file input
            event.target.value = '';
        }

        function exportWorkstream(index) {
            const page = getCurrentPage();
            if (!page) return;

            const workstream = page.workstreams[index];
            if (!workstream.tickets || workstream.tickets.length === 0) {
                alert('No tickets to export. Please refresh the workstream first.');
                return;
            }

            // Prepare CSV data
            const headers = ['Key', 'Summary', 'Status', 'Assignee', 'Story Points', 'Type', 'Epic Key', 'Epic Name', 'Parent Key', 'Parent Name'];
            const rows = [headers];

            workstream.tickets.forEach(ticket => {
                rows.push([
                    ticket.key || '',
                    ticket.summary || '',
                    ticket.status || '',
                    ticket.assignee || '',
                    ticket.storyPoints || '',
                    ticket.type || '',
                    ticket.epicKey || '',
                    ticket.epicName || '',
                    ticket.parentKey || '',
                    ticket.parentName || ''
                ]);
            });

            // Convert to CSV format
            const csvContent = rows.map(row =>
                row.map(cell => {
                    // Escape quotes and wrap in quotes if contains comma, quote, or newline
                    const cellStr = String(cell).replace(/"/g, '""');
                    return /[",\n]/.test(cellStr) ? `"${cellStr}"` : cellStr;
                }).join(',')
            ).join('\n');

            // Create filename with workstream name and timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const safeName = workstream.name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
            const filename = `${safeName}-${timestamp}.csv`;

            // Download as file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            alert(`Exported ${workstream.tickets.length} tickets to ${filename}`);
        }

        // Recovery function - can be called from browser console
        window.recoverFromLocalStorage = function() {
            console.log('Checking localStorage for backups...');

            const mainBackup = localStorage.getItem('workstreams');
            if (mainBackup) {
                console.log('Found main backup:', mainBackup);
            }

            const backupKeys = Object.keys(localStorage).filter(k => k.startsWith('workstreams_backup_'));
            console.log(`Found ${backupKeys.length} timestamped backups`);

            backupKeys.sort().reverse().forEach((key, i) => {
                const timestamp = key.replace('workstreams_backup_', '');
                const date = new Date(parseInt(timestamp));
                const backup = localStorage.getItem(key);
                console.log(`Backup ${i + 1} (${date.toLocaleString()}):`, backup);
            });

            if (mainBackup || backupKeys.length > 0) {
                console.log('\nTo recover, run: window.restoreBackup(backupNumber)');
                console.log('Example: window.restoreBackup(1) for the most recent backup');
            } else {
                console.log('No backups found in localStorage');
            }
        };

        window.restoreBackup = async function(backupNumber = 0) {
            let backupData;

            if (backupNumber === 0) {
                // Restore from main backup
                backupData = localStorage.getItem('workstreams');
            } else {
                // Restore from timestamped backup
                const backupKeys = Object.keys(localStorage).filter(k => k.startsWith('workstreams_backup_')).sort().reverse();
                if (backupNumber <= backupKeys.length) {
                    backupData = localStorage.getItem(backupKeys[backupNumber - 1]);
                } else {
                    console.error('Backup number out of range');
                    return;
                }
            }

            if (backupData) {
                try {
                    const parsed = JSON.parse(backupData);
                    if (parsed.pages) {
                        data = parsed;
                    } else if (Array.isArray(parsed)) {
                        data.pages = [{
                            id: Date.now(),
                            name: 'Main',
                            workstreams: parsed
                        }];
                        data.currentPageId = data.pages[0].id;
                    }

                    await saveWorkstreams();
                    renderTabs();
                    renderWorkstreams();
                    console.log('Backup restored successfully!');
                    alert('Backup restored! Your data should be back.');
                } catch (e) {
                    console.error('Failed to restore backup:', e);
                }
            } else {
                console.log('No backup data found');
            }
        };

        init();
    </script>
</body>
</html>
